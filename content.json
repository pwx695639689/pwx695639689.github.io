[{"title":"CSS中的布局详解笔记（一）","date":"2017-08-05T03:36:03.000Z","path":"2017/08/05/cssstudy3/","text":"从盒模型入手整理CSS的布局以及知识点详解。 一、盒模型盒模型，顾名思义，是HTML文档中每个元素在渲染的时候都会被描述成一个矩形盒子，盒模型就是表示每个元素盒子所占空间大小的模型。 盒模型主要有四个部分： margin （外边距） border （边框） padding （内边距） content （内容区域） 一般来说，默认盒模型实际占用空间计算模式为： 水平空间大小 = margin（左右）+ border（左右）+ padding（左右）+ width 垂直空间大小 = margin（上下）+ border （上下）+ padding （上下）+height 因此， 一个元素的实际大小为：border + padding + width/height 在CSS中，名为box-sizing的属性可以改变元素宽高的计算方式。 box-sizing有两个常用的取值： content-box border-boxcontent-box为默认值，实际宽高为上述元素实际大小的计算方式。border-box则是一个元素设置的width和height，不包含其他的。 二、视觉格式化模型元素能够被渲染成一个又一个盒子，那么这些盒子的位置在页面中又是如何摆放的呢？ 在默认情况下，盒子是按照元素在HTML中的先后位置从左至右从上至下一个接着一个排列放置。 但此时也分为两种情况，有的盒子呈水平排列，有的盒子却占满整个一行。这是因为不同的盒子，使用的是不同的格式化上下文来布局。 格式化上下文常见的有两种： 块格式化上下文（BFC） 行内格式化上下文（IFC） 当元素的display值为block、list-item、table、flex、grid时，它是块级元素，每个块级元素至少生成一个块级盒，块级盒参与BFC，被渲染成完整的一个新行。 W3C对于BFC的定义是： 浮动元素和绝对定位元素，非块极盒子的块级容器，以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的块级格式化上下文。在一个块级格式化上下文里，盒子从包含块的顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin来决定的，两个相邻的块级盒子的垂直外边距会发生叠加。在块级格式化上下文中，每一个盒子的左外边缘会触碰到容器的左边缘（对于从右到左的格式来说，则会触碰到右边缘），即使存在浮动也是如此，除非这个盒子创建一个新的块级格式化上下文。 总结一下BFC的特性： 内部的Box会在垂直方向，从顶部开始一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加。 每个元素的margin box的左边，与包含块border box的左边相接触，即使存在浮动也是如此。 BFC的区域不会与float box叠加 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。 计算BFC的高度时，浮动元素也参与计算。 当元素的display值为inline、inline-block、inline-table、inline-flex、inline-grid时，它是行内级元素，行内级元素生成行内级盒，参与IFC，被渲染为水平排列，直到当行被占满然后换行。 总结IFC的渲染规则： 盒子一个接一个地水平摆放，当容器宽度不够时就会换行。 在水平方向上，这些盒的外边距，边框，内边距所占用的空间都会被计算，但行内和的垂直border，padding，margin都会撑开行盒的高度。 在垂直方向上，这些盒可能会以不同形式来对齐，可通过vertical-align来设置，默认对齐为baseline 每一行将生成一个行盒，包括该行所有的盒子，行盒的宽度是由包含块和存在的浮动来决定 行盒一般左右边都贴近其包含块，但是会因为浮动和的存在而发生变化，浮动盒会位于包含块边缘与行盒边缘之间，这样行盒的可用宽度就小于包含块的宽度 当所有盒的总宽度小于行盒的宽度，那么行盒中的水平方向排版有text-align来决定 当所有盒的总宽度超过一个行盒时，就会形成多个行盒，多个行盒互相之间垂直方向不能分离，不能重叠 当一个行内盒超过行盒的宽度时，它会被分割成多个盒，这些盒被分布在多个行盒里，如果一个行内盒不能被分割，那么这个行内盒将溢出这个行盒 行盒的高度由内部元素中实际高度最高的元素计算出来，每个行盒的高度由于内容不一样，所以高度也可能不一样 在一个行盒中，当他包含的内部容器的高度小于行盒的高度的时候，内部容器的垂直位置可由自己的vertical-align属性来确定 在IFC中，是不能存在块级元素的，如果将块级元素放入IFC，那么会被破坏成BFC，而块级元素前的元素或文本和块级元素后的元素或文本将会各自自动产生一个匿名块盒将其包围。 三、一些易混淆的概念块元素与块级元素块级元素：块级元素是那些视觉上会被格式化成块状的元素，也就是会换新行的元素。块元素：块元素是display属性值为block的元素，他应该是块级元素的一个子集。 行内元素与行内及元素行内级元素：行内级元素是不会为自身内容形成新的块，而让内容分布在多行中的元素。行内元素：行内元素仅仅是display值为inline的元素，是行内及元素的一个子集。 block，inline，inline-blockblock和inline这里不再赘述，重点说一下inline-block：inline-block是将元素呈现为inline，但元素的内容却又作为block呈现，既具有block的宽高特性，又具有inline的同行特性。 参考资料： 腾讯课堂前端NEXT课程文档——视觉格式化模型","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://chronosblog.top/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"}]},{"title":"总结CSS中的单位","date":"2017-08-03T12:00:41.000Z","path":"2017/08/03/cssstudy2/","text":"总结CSS中的单位以及用法。 CSS中的单位pxpx（像素）是CSS中最为常用的一种单位，传统上一个像素对应计算机屏幕上的一个点，对于高清屏则对应更多。 %百分比也较为常用。其中对font-size设置百分比值时，是以浏览器默认字体大小16px为参照计算的。 emem是一种计算方式为相对于父元素的字体大小的单位，1em等于父元素设置的字体大小，如果父元素没有设置字体大小，则继续往父元素查找，直到有设置大小的，若都没有设置大小，则使用浏览器默认大小。 CSS中常用属性里使用em这样计算方式的属性有： border width height padding margin line-height 例如：1234p&#123;font-size: 16px;padding: 1.5em /*此处1.5em=1.5*16px*/&#125; remrem和em类似，也是相对单位。rem的参照物是根元素HTML的font-size，因此，如果改变HTML的font-size值，那么所有使用的rem单位大小都会随着改变，适用于移动端。（不支持IE8以下） v系单位v系单位常用于移动端，是基于浏览器用来显示内容的区域大小，也就是视窗大小来就算的。具体分为4个： vw：基于视窗的宽度计算，1vw等于视窗宽度的百分之一 vh：基于视窗的高度计算，1vh等于视窗高度的百分之一 vmin：基于vw和vh中最小值来计算，1vmin等于最小值的百分之一 vmax：基于vw和vh中最大值来计算，1vmax等于最大值的百分之一 单位运算CSS中可以使用CSS函数calc()来通过计算确定一个属性的值。例如：1width:calc(100%-80px);","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://chronosblog.top/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"}]},{"title":"总结CSS基础中的一些小坑","date":"2017-08-01T15:45:41.000Z","path":"2017/08/01/cssstudy1/","text":"CSS虽然很有趣，入门也容易，但对于前端菜鸟、初学者来说，还是有一些小坑是无法避免的，这些小坑相对而言更需要去积累和理解，也是比较容易忽略的一些问题，以至于学到后来，因为没有搞定这些小坑而延伸出许多“大坑”，相当影响学习效率。 一、CSS选择器CSS中的选择器大体分为五大类： 基本选择器 关系选择器 伪类选择器 伪元素选择器 属性选择器 这五大类里每一类又分别有很多类型的选择器，可以说是一个庞大的“选择器”家族。然而，在实际使用过程当中，用的最多的其实也就那么几种而已，比如标签选择器，类选择器，ID选择器等。那么，我们在需要使用选择器的时候，优先考虑的究竟是什么呢？这时候有的同学肯定会疑惑，难道不是哪个更方便就用哪个吗？ 其实不然。我们从零学习前端开发，最终的目标实际上是做一个合格的开发者，所以优先考虑的肯定是“合格”二字。所以，在使用选择器的时候，我们要考虑选择器优化这个概念。 对于浏览器来说，解析每种选择器所耗费的时间并不一样，那么如何才能写出最优选择器呢？ (引用内容来源于IMWeb的技术文章) 根据网站效率专家Steve Souders指出，各种CSS选择器的效率由高到低排序如下： id选择器 类选择器 标签选择器 相邻选择器 子选择器 后代选择器 通配符选择器 属性选择器 伪类选择器 假如现在需要对一个p元素来使用选择器： &lt;p id=&quot;text&quot; class=&quot;red&quot;&gt;这是一个段落&lt;p&gt; 我们可以通过很多方法选中它，标签选择器，类选择器，id选择器都能做到，但按照执行效率来说，id选择器是最佳的，其次是类选择器，然后是元素选择，最后才是属性选择器。 这里有一个小例子，作为一个前端新手，我刚开始练习CSS的时候，习惯在例子中使用了通用选择器“*”来清除margin和padding： *{margin: 0; padding: 0;} 直到后来，看到别人清除浏览器默认样式的时候都写一大长串，甚至引入一个专门的CSS文件来用于清除默认样式，我十分不解，用通用选择器岂不是更方便？ 后来才明白，这样做反而是最没有效率的！原因在于浏览器匹配文档中所有的元素后会分别向上逐级匹配，一直到文档的根节点才作罢，这样匹配的开销是非常大的。所以，应当避免使用通用选择器。 还有一个问题很关键：浏览器又是如何识别你写的选择器的呢？ 实际上，浏览器读取你的选择器，遵循的原则是从选择器的右边到左边读取。也就是说，顺序是从右到左。 所以当你给一个元素写了相当多的选择器，浏览器会从右到左来寻找，显然路径链会影响效率。因此，建议选择器的层级最多不要超过四层。 综上所述，在使用选择器的时候，其实要做一个综合考虑，每一次都用最优解来使用，这样才能提高代码的效率。 二、CSS优先级CSS中的优先级大概如下： ！important &gt; style &gt; id选择器 &gt; 类选择器 &gt; 元素选择器 &gt; “*” &gt; 浏览器默认 &gt; 继承 这样的优先级比较方式比较笼统，所以还有一种比较普遍的简化方式： 我们把每一个选择器都用一个数字（权重值）来表示，元素选择器用个位数，类选择器用十位数，id选择器用百位数。 选择器 权重值 id选择器 100 类选择器 10 元素选择器 1 于是，权重的计算我们可以总结如下图所示： 其中，没选中代表的就是继承来的属性。 知道了选择器的优先级，那么元素最终的样式究竟是如何得出的呢？ 我们知道，一个元素的样式来源有： 继承自父级元素的样式 浏览器的默认样式 元素自己声明的样式 最终应用的样式就是通过一系列复杂的计算体系而得到的。而这里面有几个值需要注意。 应用值（used value）、初始值（initial value）、（inherit value）最终应用的样式称之为应用值，如果一个元素声明了样式，那么应用值就是这个声明的样式，但如果没有声明，那应用值又是什么？ 这里还包括了两个特殊的值：继承值和初始值。 一个属性默认是继承的，我们得到的它的父元素的同属性的应用值就叫做继承值。如果属性是默认不继承的，那么就会有一个初始值，这个初始值实际上就是一个默认的值，比如width的初始值是auto。 三、CSS重置有关CSS重置之前已经提到过，就是清除浏览器默认样式。 对于不同的浏览器，其默认样式都是不一样的，而且默认样式有时候实际上就如同画蛇添足一般，清除是非常必要的。 CSS重置分为两种，一种是纠正重置，一种是清零重置 纠正重置，就如字面意思，因为浏览器默认样式有差异的缘故，我们需要来消除这些差异，让页面在不同的浏览器中看起来一致。开源的normalize.css就可以做到这一点，这里不再赘述。 清零重置，就是彻底的去除默认样式，这个可以根据自己的需求来写，也可以参考一些文档，例如：Eric Meyer’s Reset CSS 2.0 我的个人Blog：chronosblog.top我的微信公众号：runtustory","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://chronosblog.top/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"}]},{"title":"杂文随笔分类","date":"2017-07-30T06:54:28.000Z","path":"2017/07/30/zawen/","text":"#这里放杂文随笔这里放杂文随笔","categories":[{"name":"杂文","slug":"杂文","permalink":"http://chronosblog.top/categories/杂文/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://chronosblog.top/tags/随笔/"}]},{"title":"这里是小说连载","date":"2017-07-30T06:52:55.000Z","path":"2017/07/30/novel/","text":"#这里是小说的连载这里是小说的连载","categories":[{"name":"小说","slug":"小说","permalink":"http://chronosblog.top/categories/小说/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://chronosblog.top/tags/小说/"}]},{"title":"编程分类","date":"2017-07-30T06:49:16.000Z","path":"2017/07/30/code/","text":"#这里面放编程类的文章这里面放编程类的文章","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/tags/编程/"}]}]