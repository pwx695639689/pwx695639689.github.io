[{"title":"我在心慌什么","date":"2018-07-22T13:00:00.000Z","path":"2018/07/22/diary-2018-7-22/","text":"夏末的南方城市，它令人心慌 最近很喜欢听李志的《春末的南方城市》。 像是真如歌词那样，唱出了我的心慌，恰如其分。 相信在深圳这座城市里，大部分人都一样，在心慌，像是一场期末考没有准备好的那种心慌。 但没有人真的会去问自己，你在心慌什么。 心慌源于浮躁。 我是个浮躁的人，正如这个浮躁的世界，我有很多很多欲望，这个世界也充斥着很多很多欲望。五颜六色的欲望潜藏在灵魂里，时时刻刻在挠你的痒，但你却又无可奈何，只能忍受着这样的痛苦，继续着令自己作呕、也无法让自己左右的生活。 看了姜文的《邪不压正》，心中艳羡不已。正如他的电影一样，在他的世界里，他可以主宰一切，可以让他的世界充斥着自己浓烈的灵魂味儿，每一阵风，每一片云，每一片油菜花地，都有他的荷尔蒙味儿。 姜文这样一个大院儿出身，骨子里带着精英主义的人，却也能够对无产阶级、人民群众的世界感同身受，这样一个分裂的人，像极了古时候劫富济贫、浪迹天涯的侠客，但他又说了：他不信侠。 记得姜文说过，他能做的只有去表达自己。可这个世界上，又有多少人是沉默的大多数，何谈表达自己。 姜文是再让这个世界染上属于他的色彩，而我们大多数人，却是被这个世界染上难以言喻的颜色。出发点都不同，何谈共鸣？ 我后来才想明白，可能唯有这样的人，才不会心慌。 我们都得为自己的每一个选择而埋单，毕竟那都是我们自己的选择。","categories":[{"name":"杂文","slug":"杂文","permalink":"http://chronosblog.top/categories/杂文/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://chronosblog.top/tags/随笔/"}]},{"title":"《你》","date":"2018-04-18T14:52:55.000Z","path":"2018/04/18/novel-1/","text":"初相逢，惊鸿一瞥，乱我心曲。","categories":[{"name":"小说","slug":"小说","permalink":"http://chronosblog.top/categories/小说/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://chronosblog.top/tags/小说/"}]},{"title":"一千零一面镜子","date":"2018-04-17T15:37:00.000Z","path":"2018/04/17/diary-2018-4-17/","text":"一千零一面镜子，转映着你的容颜，我从你开始，我在你结束 我一直相信眼睛是心灵的窗户，但我不知道是否真的是这样。 我算是一个不善言辞的人，于是在表达感情的时候略显笨拙，只能靠眼神输出。但很少有人会去关注你的眼神，你的瞳孔，因为你心的波动而千变万化的眸子。不管你说话，还是写字，你都有可能违背初心，也有可能掩藏心迹，但眼神不会，它是通往灵魂深处的通道，七情六欲再如何克制，掩藏，也很难不从眼神中溢出。 人类是十分感性的动物，在感性的时候，理性是完全被屏蔽的，这一点我颇有感触。 平日里那种患得患失的心情，还真不是理性能够克制的了的。明明觉得这样很傻，但还是能笑着继续，傻并快乐着。 曾经看《蝙蝠侠 黑暗骑士》这部电影的时候，我很喜欢小丑，我觉得他是个疯子，我喜欢他的原因在于他无法用正常的逻辑去解读，这个世界最不缺的就是逻辑，我们改变不了这个世界定好的逻辑，那就只能委屈自己去适应，就像是咸鱼一样，翻个身，还是咸鱼。 越没有逻辑的东西，往往越简单，也越复杂。这个世界有两个极端，一个是喜欢把简单的事情复杂化，另一个是喜欢把复杂的问题简单化，似乎任何问题都能靠这两个极端迎刃而解。 人很少有清醒地审视自己的时候。但我认为这很重要，想要正确地认识这个世界，首先要正确地认识自己。每个人最好的朋友首先是自己，其次才是自己脑子里臆想出来的那个无所不能的多啦A梦。 理性让我们的行为有了明确的目的，而感性却又让目的变得模糊，行为变得复杂，变得难以解读。 就好像我整日里患得患失的心情，才下眉头，又上心头。","categories":[{"name":"杂文","slug":"杂文","permalink":"http://chronosblog.top/categories/杂文/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://chronosblog.top/tags/随笔/"}]},{"title":"Vue知识点总结（二）组件与生命周期","date":"2018-04-08T05:05:22.000Z","path":"2018/04/08/vue-study2/","text":"vue知识点总结 组件基础123456789// 定义一个名为 button-counter 的新组件Vue.component(&apos;button-counter&apos;, &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, template: &apos;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&apos;&#125;) 组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：123&lt;div id=&quot;components-demo&quot;&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 一个组件也拥有data、methods、computed、watch这些属性，但一个组件里，data必须是一个函数，data里的数据必须通过return返回。 一个组件必须只能有一个根元素，所以需要将组件包裹在一个父级的div容器里。 组件的注册组件的全局注册123Vue.component(&apos;my-component-name&apos;, &#123; // ... 选项 ...&#125;) 组件的局部注册12345678910111213141516import ComponentA from &apos;./ComponentA.vue&apos;export default &#123; components: &#123; ComponentA &#125;, // ...&#125;new Vue(&#123; el: &apos;#app&apos;, components: &#123; &apos;component-a&apos;: ComponentA, &apos;component-b&apos;: ComponentB &#125;&#125;) 组件模板12345678910//以VUE为后缀名的文件，有如下模板&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 父子组件传值父组件向子组件传值，是通过属性来传递的。prop是你可以在组件上注册的一些自定义特性，当一个值传递给一个prop特性的时候，它就变成了那个组件实例上的一个属性。当prop注册之后，就可以把数据作为一个自定义特性传递进来。123456789//父组件发送数据&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;&lt;blog-post title=&quot;Blogging with Vue&quot;&gt;&lt;/blog-post&gt;&lt;blog-post title=&quot;Why Vue is so fun&quot;&gt;&lt;/blog-post&gt;//子组件接受数据Vue.component(&apos;blog-post&apos;, &#123; props: [&apos;title&apos;], template: &apos;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&apos;&#125;) 子组件向父组件传值，是通过事件触发的方式来传递的：123456781.绑定 methods:&#123; handleEvent:function(msg)&#123;&#125; &#125; &lt;son @customEvent=&quot;handleEvent&quot;&gt;&lt;/son&gt;2.触发子组件内部：this.$emit(‘customEvent’,100); ref是可以让父组件得到子组件中的数据和方法：123451.指定ref属性 &lt;son ref=&quot;mySon&quot;&gt;&lt;/son&gt;2.根据ref得到子组件实例 this.$refs.mySon parent可以得到父组件的实例：1this.$parent得到父组件的实例 非父子组件间通信123456兄弟组件通信: 1.var bus = new Vue(); 2.接收方 bus.$on(&apos;eventName&apos;,function(msg)&#123;&#125;) 3.发送方 bus.$emit(&apos;eventName&apos;,123); 自定义指令12345678910111213创建和使用 Vue.directive(&apos;change&apos;,&#123; bind:function(el,bindings)&#123; //首次调用 &#125;, update:function(el,bindings)&#123; //只要是有数据变化，都会调用 &#125;, unbind:function()&#123; //解绑 &#125; &#125;) &lt;any v-change=&quot;count&quot;&gt;&lt;/any&gt; 钩子函数：12345678910111213一个指令定义对象可以提供如下几个钩子函数 (均为可选)：bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。componentUpdated：被绑定元素所在模板完成一次更新周期时调用。unbind：只调用一次，指令与元素解绑时调用。接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。 自定义指令中传递的三个参数：123el: 指令所绑定的元素，可以用来直接操作DOM。binding: 一个对象，包含指令的很多信息。vnode: Vue编译生成的虚拟节点。 过滤器1234567891011121.创建 Vue.filter( &apos;myFilter&apos;, function(myInput)&#123; //myInput是在调用过滤器时，管道前表达式执行的结果 //针对myInput，按照业务需求做处理 //返回 return &apos;处理后的结果&apos; &#125;)2.使用 &lt;any&gt;&#123;&#123;expression | myFilter&#125;&#125;&lt;/any&gt; 在调用过滤器的时候，完成参数的发送和接受12345671.发送&lt;any&gt;&#123;&#123;expression | myFilter(参数1，参数2)&#125;&#125;&lt;/any&gt;2.接受Vue.filter(&apos;myFilter&apos;,function(myInput，参数1，参数2)&#123; return &apos;处理后的结果&apos;&#125;) Vue生命周期什么是vue的生命周期 指的是实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 生命周期的作用 生命周期中有多个钩子函数，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 总共有八个阶段也就是八个钩子函数 创建前/后, 载入前/后,更新前/后,销毁前/销毁后 页面第一次加载的时候会触发beforeCreate, created, beforeMount, mounted 这几个钩子，DOM 渲染在 mounted 中就完成 每个周期的具体场景 beforeCreate 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated 由于数据更改导致的虚拟 DOM，重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://chronosblog.top/tags/Vue/"}]},{"title":"Vue知识点总结（一）基础","date":"2018-04-06T14:45:01.000Z","path":"2018/04/06/vue-study1/","text":"vue知识点总结 VUE是什么vue是一套用来构建用户界面的JavaScript框架在学习vue之前，必须要有HTML、CSS、JavaScript的扎实基础当前vue的最新版本是2.x VUE的使用 使用script标签引入 使用vue-cli来快速搭建脚手架 VUE实例每一个vue应用都是通过用vue函数来创建一个vue实例开始的：123var vm = new Vue(&#123; //选项&#125;) 每一个vue应用，都是由一个通过new Vue创建的根Vue实例和可选的、可嵌套的、可复用的组件树组成。 data对象vue中的data对象里，在vue实例创建的时候，在其响应式系统中加入了所有能在data中找到的属性，当这些属性的值发生改变的时候，视图也会响应，一起改变。123var vm = new Vue(&#123; data: data&#125;) 除了数据属性，vue实例中还暴露了一些有用的实例属性和方法。它们都有前缀$，可以和用户定义的属性区分开来 模板语法###文本数据绑定最常见的是“mustache”语法，也就是双大括号：1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;span&gt; 双大括号里的内容将会被替代为数据对象上面的msg属性的值，如果绑定的这个属性的值发生改变，那么大括号内的内容会跟着更新。在数据绑定里，还可以支持JavaScript表达式（非语句）。 内部指令vue内部可以使用在HTML上，HTML会根据这些指令来执行对应的任务，响应式地作用于dom。 v-html双大括号里会把数据解释为普通文本，而不是HTML，所以如果想输出真正的HTML，那就要使用v-html命令：1&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; v-bind假如你想像双大括号语法一样修改HTML的属性，那么这时候用双大括号就不行了，需要使用v-bind语法：1&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 这个指令还有一个常用的缩写形式：1&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt; v-on这个指令可以用来监听DOM事件，并在触发时运行一些JavaScript代码1&lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1 &lt;/button&gt; v-on里还可以接受一个需要调用方法的名称。如果需要在内联语句处理器中访问原始的DOM时间，可以使用特殊变量$event把它传入方法。 vue还为v-on提供了事件修饰符： .stop 阻止事件继续传播 .prevent 提交的事件不再阻止页面 .capture 添加事件监听器时使用事件捕获模式 .self 只当在event.target是当前元素自身时触发处理函数 .once 点击事件将只触发一次 .passive 滚动事件的默认行为将会立即触发 按键修饰符1&lt;input v-on:keyup.13=&quot;submit&quot;&gt; 除了根据keycode来调用键值，还可以使用vue提供的别名，比如enter等。 条件渲染 v-if条件渲染可以根据条件来决定是否渲染dom：1&lt;h1 v-if=&quot;ok&quot;&gt;&lt;/h1&gt; 也可以使用v-else来添加一个else块，v-else元素必须跟在v-if 的后面。还有v-else-if。 当想切换多个元素的时候，可以在template元素上使用v-if，template就可以当做不可见的元素。 假如两个模板使用了相同的HTML元素，在进行切换的时候，这个元素是不会更新的，这时候就可以使用key值来给这个元素做一个绑定，这个key值是唯一的，因此同一个元素上绑定的两个key值可以让这两个元素都是独立的。 v-show这个命令可以根据条件选择是否展示元素。1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; v-if 和v-show的区别v-if是真正的条件渲染，在切换的时候会有适当的销毁和重建，如果是假，那么就会什么也不渲染。而v-show则是一个改变元素display的指令，只是基于CSS的切换。 v-forv-for可以根据一组数据的选项列表来进行渲染，语法比较特殊：123456789101112131415&lt;ul id=&quot;example-1&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;var example1 = new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; items: [ &#123; message: &apos;Foo&apos; &#125;, &#123; message: &apos;Bar&apos; &#125; ] &#125;&#125;) 其中的items是原数据数组，定义在data里，而item则是数组元素迭代的别名。也可以取整数表示重复。 v-for还支持一个可选参数，当做数组的索引。12345&lt;ul id=&quot;example-2&quot;&gt; &lt;li v-for=&quot;(item, index) in items&quot;&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 其中的in也可以被of所替代 。 v-for还可以操作对象，通过一个对象的属性来进行迭代。如果设置第二个参数key，那么就是属性名。 当使用v-for的时候，如果更新已经渲染的元素列表，那么v-for会就地复用，为了方便它可以跟踪每一个节点的身份，所以必须要给一个key值，每项都有唯一的id。 变异方法这些针对于数组的方法都能够改变原始数组，而非变异方法则不会改变原始数组，而是返回一个新的数组。和原生js的数组操作方法一样，如push()等。 v-for和v-ifv-for和v-if处于同一节点的时候，v-for比v-if的优先级要高。 表单输入绑定可以使用v-model指令在表单元素上创建双向绑定。12&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 表单输入绑定的修饰符 .lazy修饰符可以转变为使用change事件时进行同步 .number 如果想自动给用户的输入值转为数值类型 .trim 如果要自动过滤用户输入的首尾空白字符 class与style绑定我们可以给v-bind:class传一个对象，动态的切换class：1&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt; 方法、计算属性与侦听器数据我们可以定义在data里，方法我们可以定义在methods里。当然，除了方法之外，还有一些复杂的逻辑，我们可以使用计算属性。123456789101112131415161718&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) 与方法不同，计算属性是基于它们的依赖进行缓存的，只在相关依赖发生改变时才会重新求值。 Vue还提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。1234567891011121314var watchExampleVM = new Vue(&#123; el: &apos;#watch-example&apos;, data: &#123; question: &apos;&apos;, answer: &apos;I cannot give you an answer until you ask a question!&apos; &#125;, watch: &#123; // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) &#123; this.answer = &apos;Waiting for you to stop typing...&apos; this.debouncedGetAnswer() &#125; &#125;&#125;) 未完待续……","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://chronosblog.top/tags/Vue/"}]},{"title":"Javascript总结笔记之面向对象知识点详解","date":"2017-12-01T05:25:03.000Z","path":"2017/12/01/js-study-2/","text":"面向对象之创建对象、原型、继承、this。 一、创建对象对象是一个无序属性的集合，其属性可以包括基本类型值、对象和函数。 创建对象有两种方式： 第一种是创建一个object的实例： 123456var person = new Object();person.name = &apos;easy&apos;;person.age = 22;person.say = function()&#123; console.log(this.name);&#125; 第二种是字面量： 1234567var person = &#123; name: &apos;easy&apos;, age: 22, say: function()&#123; console.log(this.name); &#125;&#125; 对象的属性类型对象的属性类型是ECMAscript定义的只有内部才用的特性，描述了属性的各种特征。 属性类型分为数据属性和访问器属性 数据属性有4个描述特性： 1.[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。比如直接在对象上定义的属性，它们的这个特性默认值为true。 2.[[Enumerable]]：表示能否通过for-in循环返回属性。对于直接在对象上定义的值，默认为true。 3.[[Writable]]：表示能否修改属性的值。 4.[[Value]]： 包含这个属性的数据值。读取属性值时，从这个位置读；写入属性值时，把新值保存在这个位置。默认值为undefined。 修改属性默认的特性，需要使用defineProperty()方法，这个方法接受三个参数：属性所在的对象，属性的名字，描述符对象。 访问器属性也有4个描述特性： 1.[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。比如直接在对象上定义的属性，它们的这个特性默认值为true。 2.[[Enumerable]]：表示能否通过for-in循环返回属性。对于直接在对象上定义的值，默认为true。 3.[[Get]]：在读取属性时调用的函数，默认为undefined 4.[[Set]]：在写入属性时调用的函数，默认为undefined 访问器属性也需要使用defineProperty()方法来定义。 如果需要定义多个属性，Object.defineProperties()方法可以通过描述符一次定义多个属性，这个方法接收两个对象参数，第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象要添加或修改的属性一一对应。 如果需要读取属性的特性，Object.getOwnPropertyDescriptor()方法可以取得给定属性的描述符，它接受两个参数：属性所在的对象和要读取其描述符的属性名称，返回来的是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value。 判断是否是对象判断一个变量是否是对象，如果是值类型就使用typeof，如果是引用类型就使用instanceof。 工厂模式由于无法创建类，所以设计了一种封装函数用来创建对象，叫做工厂模式： 123456789101112function createPerson(name,age,job)&#123; var o = new Object() o.name = name o.age = age o.job = job o.sayHello = function()&#123; alert(this.name) &#125; return o&#125;var person1 = createPerson(&quot;111&quot;,&quot;222&quot;,&quot;333&quot;); 构造函数工厂模式虽然解决了创建多个相似对象的问题，但是没有解决如何知道一个对象的类型的问题，因此这时候需要使用构造函数： 12345678910function Person(name,age,job)&#123; this.name = name this.age = age this.job = job this.sayName = function()&#123; alert(this.name) &#125;&#125;var person1 = new Person(&quot;222&quot;,&quot;333&quot;,&quot;222&quot;) 构造函数也是函数，假如不使用new来创建对象，其实和普通函数也没有什么区别。 构造函数的特点：1.没有显示的创建对象。2.把属性和方法都赋值给了this。3.没有使用return语句。 那么，在创建一个对象的时候，使用new操作符的时候经历了哪些步骤呢？ 1.首先创建了一个新的对象。2.将构造函数的作用域赋值给这个新对象（this指向）。3.执行构造函数中的代码，也就是给对象添加属性和方法4.返回这个新对象。 但是构造函数也有缺陷，其中的每一个方法都要在每一个实例上重新创建一遍，创建很多完成相同任务的function实际上完全没有必要，解决这个问题就需要用到原型。 二、原型与原型链我们创建的每一个函数，都自带一个属性叫prototype原型属性，这个属性是个指针，指向的是一个对象，这个对象是用来包含由特定类型的所有实例共享的属性和方法。 具体一点说，prototype就是通过构造函数创建的那个对象的原型对象，原型对象就是可以让所有对象实例都可以共享其属性和方法。 如何理解原型呢？ 首先，我们创建了一个函数，这个函数会自带一个属性叫prototype，这个属性指向的是函数的原型对象。在我们创建函数的时候，相当于使用函数的原型对象创建一个实例。 在原型对象上面，也有一个自带的属性，叫做constructor，这个属性指向的就是包含prototype属性的函数实例。 所以可以说，一个函数的prototype属性指向的是函数的原型对象，那么原型对象的constructor属性指向的就是这个函数。 在我们自定义一个构造函数的时候，这个构造函数的原型对象就只有一个自带的constructor属性，其他的属性都是从Object()里继承过来的。 接下来我们开始使用构造函数创建对象了。用构造函数创建的对象，也和原型有关系。 假如我们使用构造函数创建了一个实例对象，这个实例对象内部也包含一个内部属性，也是一个指针，指向的就是构造函数的原型对象，叫做[[prototype]],或者为proto,这个东西没有什么标准的访问方式。 这个属性的意义很重要，它是构造函数创造出来的实例和构造函数的原型对象之间的关系。 所以每当代码读取某个对象的某个属性的时候，会执行一次搜索，首先从对象实例本身开始搜索，如果搜索到相关的属性就返回，如果没有，就去这个对象实例指针指向的原型对象中搜索。 当我们给一个对象实例添加一个属性的时候，这个属性会屏蔽原型对象中的保存的同名属性，所以添加这个属性只是阻止我们访问原型中的属性，但不会修改原型中的属性。 假如你重写了原型对象，那么会切断现有原型和任何之前已经存在的对象实例之间的联系，这些对象引用的仍然是最初的原型。 因此，创建对象最佳的办法就是，把公有的属性和方法写在原型里，私有的属性写在构造函数里，组合使用构造函数和原型。 这时候，我们又需要思考继承的问题，首先需要知道什么是原型链。 每一个构造函数，都有一个原型对象，原型对象里有指向这个构造函数的指针。构造函数创建的实例对象里，包含的是指向构造函数原型对象的指针。如果这时候，让这个原型对象等于另一个类型的实例，这个实例还有一个构造函数，这个构造函数还有一个原型对象，这样以此类推，就形成了原型链。 还有一个要注意的，就是所有函数的默认原型，都是Object对象的实例。 继承的最佳实践就是，继承属性使用call方法借用构造函数，方法通过一个封装函数利用原型链来实现。 12345678910111213141516171819202122232425262728293031/** * Person * @param &#123;String&#125; name */function Person(name) &#123; this.name = name;&#125;Person.prototype.sayHello = function() &#123; console.log(&apos;Hi! My name is &apos; + this.name + &apos;.&apos;);&#125;/** * * 注意使用下面 inheritPrototype 函数实现继承原型*/function Student(name,grade) &#123; Person.call(this,name); this.grade = grade;&#125;inheritPrototype(Student, Person);Student.prototype.sayGrade = function() &#123; console.log(&apos;I am Grade &apos; + this.grade + &apos;.&apos;);&#125;// 继承原型的函数function inheritPrototype(subType, superType)&#123; var protoType = Object.create(superType.prototype); protoType.constructor = subType; subType.prototype = protoType;&#125; 三、作用域JavaScript分为全局作用域和局部作用域，但是没有块级作用域。 全局作用域就是在代码里任何地方都能够访问到的对象拥有的作用域。 一般来讲，有以下几种情况： 1.在最外层的函数和最外层函数外面定义的变量拥有全局作用域 2.所有未定义而直接赋值的变量被自动声明为全局作用域里的变量 3.所有window对象的属性 局部作用域则是被限定在一定的范围内，最常见的是在函数内部，叫做函数作用域。 那么，函数调用的时候都发生了什么？ 首先，创建一个执行环境和相应的作用域链。作用域链的先后顺序是从内而外，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，直到作为作用域链终点的全局执行环境 然后，使用arguments和其他命名参数来初始化函数的活动对象。 匿名函数模仿块级作用域：(function(){})() 4.this的指向this的指向在不同的情况下都有所不同，但它永远指向当前对象，也就是说，返回的是属性或方法当前所在的对象。 有几种具体的情况： 1.全局范围内，this指向全局对象 2.在全局范围内调用函数时，this也指向全局对象 3.方法调用时，指向当前所在的对象。 4.调用构造函数时，在函数内部，this指向的是新创建的实例对象 5.显式的改变this的值 改变this指向的方法JavaScript提供了call、apply、bind这三个方法，来切换/固定this的指向。 （1）call() 语法： call([thisObj[,arg1[, arg2[, [,.argN]]]]])定义：调用一个对象的一个方法，以另一个对象替换当前对象。说明： call方法可以用来代替另一个对象调用一个方法。call方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 （2）apply() 语法： apply([thisObj[,argArray]])定义：应用某一对象的一个方法，用另一个对象替换当前对象。说明： 如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。 如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。 bind()方法 bind()方法是在ECMAScript 5中新增的方法。 toString()方法函数的toString方法返回函数的源码。 1234567function f()&#123; return 1;&#125;f.toString() //function f()&#123;// return 1;//&#125; （3）bind() bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 1234567891011var bar=function()&#123; console.log(this.x); &#125;var foo=&#123; x:3 &#125; bar(); bar.bind(foo)(); /*或*/var func=bar.bind(foo); func(); 输出：undefined3","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://chronosblog.top/tags/Javascript/"}]},{"title":"学习使用less","date":"2017-11-02T13:45:02.000Z","path":"2017/11/02/less-study/","text":"less的学习与相关知识点的总结 Less是什么Less是一种动态样式语言，属于CSS预处理器的一种，它使用类似CSS的语法，为CSS赋予了动态语言的特性，如变量，继承，运算，函数等，更方便CSS的编写与维护。 Less可以在多种语言，环境下使用，包括浏览器端，桌面端，服务端。 Less中的注释可以使用//作为less文件中的注释。 Less中的变量Less中声明变量的话，需要使用“@”符号，例如：1@width1 = 300px; Less中的混合在Less中，我们可以定义一些通用的属性集为一个class，然后在另一个class中直接调用这些属性。例如： 1234.bordered &#123; border-top: dotted 1px black; border-bottom: solid 2px black;&#125; 上面这个属性就可以直接被调用： 1234.post a &#123; color: red; .bordered; //调用属性&#125; 带参数混合还可以像函数一样定义参数,参数还可以设置默认值，如果设置了默认值的话，使用的时候就无需声明变量的值了： 12345.border-radius (@radius) &#123; border-radius: @radius; -moz-border-radius: @radius; -webkit-border-radius: @radius;&#125; 这样想使用的时候，直接拿来使用就可以了： 123.button &#123; .border-radius(6px); &#125; 不带参数的属性集合定义不带参数的属性集合，如果想隐藏这个属性集合，不让它暴露在CSS中，但还是想在其他的属性集合中引用，可以这样定义： 12345678.wrap () &#123; text-wrap: wrap; white-space: pre-wrap; white-space: -moz-pre-wrap; word-wrap: break-word;&#125;pre &#123; .wrap &#125; @arguments变量@arguments变量包含所有传递进来的参数，如果不想单独处理某一个参数，可以使用这个变量： 123456.box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) &#123; box-shadow: @arguments; -moz-box-shadow: @arguments; -webkit-box-shadow: @arguments;&#125;.box-shadow(2px, 5px); 模式匹配模式匹配类似于JS里的if，但也不完全是。 我们可以根据传入参数的不同，来实现不同的混合的默认呈现： 123456789.mixin (dark, @color) &#123; color: darken(@color, 10%);&#125;.mixin (light, @color) &#123; color: lighten(@color, 10%);&#125;.mixin (@_, @color) &#123; display: block;&#125; 其中@_相当于每一个混合实例中都会添加的属性。 现在，如果是这样： 12345@switch: light;.class &#123; .mixin(@switch, #888);&#125; 就会选中.mixin的这一个匹配： 123.mixin (light, @color) &#123; color: lighten(@color, 10%);&#125; Less里的运算Less里是可以使用+、-、×、/这些运算符，来进行一些数值的运算。 导引Less里使用导引混合来实现条件判断，比如： 123456789.mixin (@a) when (lightness(@a) &gt;= 50%) &#123; background-color: black;&#125;.mixin (@a) when (lightness(@a) &lt; 50%) &#123; background-color: white;&#125;.mixin (@a) &#123; color: @a;&#125; 这里面的when关键字就相当于if语句，可以判断亮度在每个不同条件下，使用哪一条属性。 Less里的嵌套规则Less里可以编写像JS里函数嵌套那样的写法，比如： 12345678910#header &#123; color: black; &#125;#header .navigation &#123; font-size: 12px;&#125;#header .logo &#123; width: 300px; &#125;#header .logo:hover &#123; text-decoration: none;&#125; 像平常这样的写法，可以使用嵌套来写： 1234567891011#header &#123; color: black; .navigation &#123; font-size: 12px; &#125; .logo &#123; width: 300px; &amp;:hover &#123; text-decoration: none &#125; &#125;&#125; 看起来感觉要比常规写法更加清晰明了，像是dom结构格式。 还可以使用&amp;符号来当做串联选择器，而不是后代选择器。也就是说，&amp;指的是上一层选择器，比如写：hover这样的选择器时，就可以用到&amp;来写入嵌套内。 命名空间在less里，可以将一些变量或者是混合模块打包起来，以方便后续调用： 12345678910#bundle &#123; .button () &#123; display: block; border: 1px solid black; background-color: grey; &amp;:hover &#123; background-color: white &#125; &#125; .tab &#123; ... &#125; .citation &#123; ... &#125;&#125; 后续调用只需要引入就可以： 1234#header a &#123; color: orange; #bundle &gt; .button;&#125; 作用域Less中的作用域有点类似js中的作用域，在查找变量的时候首先会在本地查找变量或者混合模块，没找到的话就会去父级作用域中查找，直到找到为止。 123456789101112@var: red;#page &#123; @var: white; #header &#123; color: @var; // white &#125;&#125;#footer &#123; color: @var; // red &#125; importing当引入一个less文件时，可以直接这样： 1@import &quot;style.less&quot;; 避免编译有时候需要输出一些不正确的CSS语法或者使用一些LESS不认识的专有语法，要输出这样的值，直接在字符串前加一个~就好。","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://chronosblog.top/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"},{"name":"less","slug":"less","permalink":"http://chronosblog.top/tags/less/"}]},{"title":"Javascript总结笔记之基本概念","date":"2017-10-07T02:55:34.000Z","path":"2017/10/07/js-study-1/","text":"Js总结笔记之基本概念 学习一门编程语言，首先要搞清楚其基本语法。就像是看一本小说，首先需要知道主人公是谁。 一、变量如果说JavaScript是一本小说的话，那么主角一定是变量。它是如何使用这门语言的关键。和其他编程语言有所不同，JavaScript中的变量是松散类型的，可以用来保存任何类型的数据。定义一个变量，就像是给小说的主人公起名字一样容易：var message = hi;一本小说当然不可能只有主角，其他角色也很关键。而变量当然也不止一个。因此，可以使用一条语句定义多个变量。 123var message = &quot;hi&quot;; found = false; age = 6; 二、数据类型在JavaScript中，总共有6种数据类型。 简单数据类型： undefined（未定义） Boolean（布尔值） string（字符串） number（数值） Null（空） 复杂数据类型： object（对象） 那么，如何知道一个数据的数据类型呢？ 1、typeof操作符对一个值使用typeof操作符，通过返回的字符串便可以得知这个值的数据类型。例如： 12alert(typeof 66); // &quot;number&quot;alert(typeof &quot;star&quot;);// &quot;string&quot; 调用typeof,null会返回“object”，这是因为null是一个特殊值，被认为是一个空的对象的引用。但调用typeof function 却会返回“function”，虽然函数在ECMAscript中是对象，不是一种数据类型，但是函数有一些特殊的属性，所以用typeof区分函数和其他对象是有必要的。 2、undefined类型undefined，如同它的字面意思，就是“未定义”。在使用var声明变量但未对其进行初始化的时候，这个变量的值就是undefined。 12var i;alert(i); // &quot;undefined&quot; 但要注意一点，没有使用var声明的变量，虽然也可以使用typeof操作符返回undefined值，但这样会造成一个问题：当我们对一个变量使用typeof操作符，如果返回了undefined，却无法得知这个变量是否被声明，因此，使用变量前一定要声明变量。 3、Null类型Null也只有一个值，这个值是null。用typeof检测null值时会返回object，因为null表示一个空对象指针。 Null值实际上和undefined有这样的关系：alert(null == undefined); // trueundefined值是派生自null值的，因此返回了true，但二者实际上用途完全不同。 4、Boolean类型说到Boolean类型，给人的第一感觉是简单明确，只有两个值true和false。true代表真，false代表假，布尔值非真既假，简单粗暴，不像我们所处的世界，除了正义和邪恶之外，还有夹杂在二者之间的灰色地带，说不清道不明。将一个值转化为其对应的Boolean值，可以调用转型函数Boolean（）。var a = &quot;star&quot;;var aAsBoolean = Boolean(a);调用之后返回的值是true还是false，取决于要转换值的数据类型和实际值。 5、Number类型ECMA-262（JavaScript标准）定义了不同的数值字面量格式。 十进制：var num = 66; 八进制：var num = 070 // 56 十六进制：var num = 0xA; //10 在进行算术运算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。 保存浮点数值和整数值不同，浮点数值必须要有一个小数点，所需要的内存空间是整数值的两倍。 使用浮点数值： var num = 0.1; 对于极大或极小的数值，可以用e表示法表示： var floatNum = 3.125e7; //31250000var floatNum = 3E-17;// 0.00000000000000003 虽然浮点数最高精度是17位小数，但使用JavaScript进行算术计算时会出现一定的误差，比如0.1+0.2：alert(0.1 + 0.2); //0.30000000000000004 0.1+0.2并没有返回0.3，这是为什么呢？ 在网上查找相关的资料中解释如下： JavaScript的number类型按照ECMA的JavaScript标准，它的Number类型就是IEEE 754的双精度数值，相当于java的double类型。IEEE 754标准《二进制浮点数算法》（www.ieee.org）就是一个对实数进行计算机编码的标准。因此精度问题不止JS这门语言独有。无论是用纸张记录数值，还是用计算机记录数值，都必须用某种编码方案来表达数值。必须理解的是，用编码表达的数值不是数值本身，而只是数值的一种人类或计算机可理解的描述。任何编码方案都有其局限，要么是表达范围（精度）方面的限制，要么是其他复杂性方面的制约。绝对完美的数值编码方案是不存在的，为了处理方便，这个标准引入了大量的折衷和妥协，建立在这种表达方式上的算法（例如除法运算）也一样。由于数值表达方式存在“缺陷”，运算结果不可避免地堆聚起越来越多的误差。按IEEE 754格式保存的浮点数精度相当于带有15、16或17位小数位数的十进制小数，由于存在二进制和十进制的转换问题，具体的位数会发生变化。要获得最高的转换精度，必须指定17位的小数——此时可以相信前15位的精度。在JavaScript中输出下面这些数值（注意不能作为字符串输出）：0.1000000000000000000000000001（28位小数）、0.100000000000000000000000001（27位小数）、0.1000000000000000000000000456（28位小数）、0.09999999999999999999999（23位小数），显示出来的结果都是数值0.1。又如，如果输出1/3的有理数表达式，结果是0.3333333333333333。因此JavaScript小数在做四则运算时，精度会丢失。当然也有一些方法可以来保证一定的精度：http://jiangzhengjun.iteye.com/blog/4…也有人总结了一些原则：原则■ 大多数Web页面不需要小数 避免使用小数，尽量设法使用整数。确保数组的索引都是整数。按分（而不是元）计算金额。百分比放大100倍计算以避免出现小数。尽可能不用除法（/）和模（%）运算，因为大多数情况下它们直接导致出现浮点数。如果必须使用除法，立即用Math.round方法回归整数运算。■ 如果必须使用浮点数，则尽可能引入冗余小数位——即在程序要求的运算精度之外，再增加小数位 如果程序需要5位数字的小数精度，则在运算中至少保留6位的小数，8位更好。冗余位越多，累计误差的影响越小。■ 避免在同一个表达式中使用相差太大或太小的数值 对两个非常接近的数值执行减法或比较操作很容易出错。将很小的数值和很大数值相加无异于浪费时间，小的数值很可能被当作0。不过，很小的数值乘以很大的数值一般不会出现问题，例如2 * 12345678会得到正确的结果24691356。但是，0.1 - 0.09的结果是0.010000000000000009。■ 用isFinite()和isNaN()检查运算结果 通过表单提交任何数值运算结果之前，一定要先检查数据的合法性。■ 慎用数值运算 程序涉及的数值运算越少，引入误差的可能就越小。视浮点数为贵客，不可任意驱使。 因为内存的限制，ECMAscript有一个最大值和最小值，如果超出这个范围内的值，则会被表示成Infinity（负数是-infinity）。若想看一个值是否介于这个范围之内，可以使用isFinite（）函数。 还有一个特殊的值：NaN。这个值表示非数值，即一个本来要返回数值的操作数未返回数值的情况。 NaN有两个非同寻常的特点： NaN ！== NaN 任何涉及NaN的操作，比如NaN/10，都会返回NaN。 而isNaN（）函数可以帮我们确定一个数值是否是NaN，也就是是否“不是数值”。 数值转换，有三个函数可以把非数值转换成数值：Number()、parseInt()、parseFloat()。 6、string类型string类型用于表示由0或多个16位Unicode字符组成的字符序列，即字符串。 字符串用单引号‘’和双引号“”表示都可以，但引号必须匹配，不能左边单引号右边双引号。 任何字符串的长度可以用length属性获得： 12var str = &apos;hello world&apos;;alert(str.length); 如果想把一个值转换成字符串，可以使用两种方法： toString()方法几乎每个值都有这个方法，但null和undefined没有这个方法。 String()转型函数 在不知道要转换的值是否是null或undefined时，可以使用这个转型函数，可以将任何值转换为字符串。如果是null，则返回null。 如果是undefined，则返回undefined。 7、object类型对象，实际上就是一组数据和功能的集合。在ECMAscript中，object类型是所有它的实例的基础，这也就是为什么说JavaScript中万物皆对象。 由于对象既关键又复杂，这里不再赘述，将会在之后专门的文章中总结对象相关的知识。 区分大小写javascript中的一切都区分大小写 标识符标识符就是函数，变量，属性的名字，或者函数的参数。 有下列规定： 第一个字符必须是字母，下划线或者美元符号$ 其他字符可以是字母，下划线，美元符号或数字 注释123// 单行注释/* 多行注释*/ 严格模式严格模式是一种不同的解析模式，启用严格模式可以在顶部添加代码： 1&quot;use strict&quot;; 在函数内部指定也可以让函数在严格模式下执行","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"},{"name":"Javascript","slug":"Javascript","permalink":"http://chronosblog.top/tags/Javascript/"}]},{"title":"纯CSS实现朋友圈评论按钮","date":"2017-09-11T12:31:02.000Z","path":"2017/09/11/cssstudy7/","text":"纯CSS实现朋友圈评论按钮 如果使用前端技术来实现微信朋友圈页面的话，其中朋友圈的评论按钮相信很多人会选择使用切图来实现，但使用纯CSS实现也不难。 使用纯CSS实现，则需要使用伪类、定位以及CSS3中的一些新属性。 首先，先构建评论按钮的HTML布局：123&lt;div class=&quot;reply-btn-container&quot;&gt; &lt;span class=&quot;reply-btn&quot;&gt;&lt;/span&gt;&lt;/div&gt; 然后便是CSS样式，首先我们设置包裹span标签的容器的属性，假设它是一个100×100的盒子，其样式如下：123456.reply-btn-container &#123; width: 100px; height: 100px; margin: 0 auto; text-align: right;&#125; 我们知道，让块级元素水平居中可以设置margin：0 auto；，行内元素水平居中可以设置text-align： center；。 在这里，设置margin：0 auto；主要是为了让盒子在页面中居中，方便查看，在实际页面中需要根据情况来设置。 而这里的text-align： right；是为了让span标签在盒子内靠右，毕竟评论按钮一般位于页面的右侧。 接下来便是span标签的样式：123456789.reply-btn &#123; width: 48px; height: 36px; background-color: currentColor; color: #8c99c1; display: inline-block; position: relative; vertical-align: middle;&#125; 在span标签的样式中，由于它是一个行内元素，无法独占一行，所以不能直接设置宽高，但是这个按钮必须是要呈现为一个有宽高的矩形，因此，我们设置它的display属性为inline-block，这样虽然它仍然不独占一行，但可以设置宽高。 这里还用到了position属性的relative，也就是相对定位。这里来解释下position的几个值有何不同： relative：相对定位，也就是相对于其正常位置（自己）进行定位，比如此处设置left：20px，就是相对自己当前的位置向左偏移20px。相对定位是不会脱离标准文档流的，只是视觉上发生了偏移，还会保持原来的占位。 absolute：绝对定位，是相对于自己最近的那个父元素进行定位（父元素必须设置相对定位或绝对定位），如若找不到符合条件的父元素，那么将相对于body进行定位。绝对定位是脱离标准文档流的，父元素容器将得不到绝对定位了的子元素的高度。而且不管是块级元素还是行内元素，绝对定位之后，display属性为block。 flixd：固定定位，是相对浏览器窗口的定位，并且脱离标准文档流。 这里使用relative是为了让之后的伪类元素使用absolute。 background-color: currentColor;这个属性中的currentColor值，currentColor表示“当前的标签所继承的文字颜色”，换种方式表示就是：currentColor = color的值。 vertical-align: middle;该属性设置元素的垂直对齐方式，此处middle为设置元素在父元素的中部。 此时，按钮矩形已经设置完毕，接下来，便是按钮左边的三角形和内部的两个小圆点了，我们通过CSS伪类来实现，主要是before和after。 before 和 after 顾名思义 其就是附着在元素前后的 伪元素，说他是伪元素的意思就是，元素不是在DOM中生成的，而是在浏览器渲染引擎渲染CSS的时候画上去的，所以你在浏览器查看元素上是看不到伪元素的HTML结果的。 CSS样式如下：123456789101112131415161718192021222324.reply-btn::before &#123; content: &quot;&quot;; width: 0; height: 0; border: 3px solid currentColor; border-color: transparent currentColor transparent currentColor; border-width: 4px 6px 4px 0; position: absolute; top: 14px; left: -6px;&#125;.reply-btn::after &#123; content: &quot;&quot;; width: 6px; height: 6px; background: #fff; position: absolute; top: 13px; left: 10px; border-radius: 25%; box-shadow: 22px 0 0 #fff; transform: translate(0, 50%);&#125; 其中transform属性是向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。在评论按钮中的另一个小圆点，是设置第一个小圆点的box-shadow属性，也就是阴影来实现的。 最后呈现效果如图所示：","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://chronosblog.top/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"}]},{"title":"CSS中的布局详解笔记（四）","date":"2017-08-15T13:36:55.000Z","path":"2017/08/15/cssstudy6/","text":"CSS中的居中。 居中一直是css里比较关键的一个概念，在多数情况下居中往往有许多种方法。 水平居中行内元素居中： text-align：center;块级元素居中： margin：0 auto； //这种方法前提必须是要为元素设置宽度，否则宽度拉伸为父级的宽度，无法实现居中效果。 利用绝对定位的“子绝父相”法，给父元素设置相对定位，子元素设置绝对定位和transform： 12345678.container &#123; position:relative;&#125;.item &#123; position:absolute; left:50%; transform:translate(-50%);&#125; 利用flex实现居中:这里列举一种常见的方式，具体请参考上篇文章： CSS中的布局详解（三） 1234.container &#123; display:flex; justify-content:center;&#125; 垂直居中行内元素垂直居中： 单行行内或文本元素，可以设置等值的padding的top值和bottom值： 12padding-top:10px;padding-bottom:10px; 还有最常用的，让行高line-height和height值相等： 12height:50px;line-height:50px; vertical-align属性，但这个属性需要设置一个类似table-cell的父级容器： 12display: table-cell;vertical-align: middle; 块级元素： 在已知元素高度的情况下，可以利用定位来实现居中： 123456789.container &#123; position:relative;&#125;.item &#123; position: absolute; top: 50%; height:100px; margin-top: -50px;&#125; 在未知元素高度的情况下，首先需要定位到容器的中心，然后再使用transform和translate属性： 12345678.container &#123; position:relative;&#125;.item &#123; position: absolute; top:50%; transform: translateY(-50%);&#125; 利用flex实现垂直居中： 123456.container &#123; display:flex; flex-direction: column; justify-content: center; align-items: center; //加上这条属性，就是水平和垂直居中&#125; 简单实例：实现半透明遮罩123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .cover &#123; position: fixed; top: 0; left: 0; bottom: 0; right: 0; background-color: rgba(0,0,0,0.7); z-index: 100; &#125; .dialog &#123; width: 280px; text-align: center; position: fixed; background-color: #fff; border-radius: 5px; top: 50%; left: 50%; z-index: 101; transform: translate(-50%,-50%); &#125; .dialog .dialog-bd &#123; padding: 20px 10px; &#125; .dialog .dialog-ft &#123; display: flex; line-height: 44px; border-top: 1px solid #dbdbdb; &#125; .dialog .dialog-ft .ft-btn&#123; flex: 1; text-align: center; cursor: pointer; border-left: 1px solid #dbdbdb; &#125; .dialog .dialog-ft .ft-btn:first-child &#123; border-left: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;cover&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;dialog-bd&quot;&gt; &lt;p class=&quot;dialog-text&quot;&gt;确认关闭窗口？&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;dialog-ft&quot;&gt; &lt;div class=&quot;ft-btn&quot;&gt;取消&lt;/div&gt; &lt;div class=&quot;ft-btn&quot;&gt;确定&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 参考资料： CSS居中 CSS居中完整指南 我的个人博客：http://chronosblog.top我的微信公众号：runtustory CSS布局详解系列索引： CSS中的布局详解（一）：视觉格式化模型 CSS中的布局详解（二）：浮动与定位 CSS中的布局详解（三）：flex布局","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://chronosblog.top/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"}]},{"title":"CSS中的布局详解笔记（三）：flex布局","date":"2017-08-10T11:56:11.000Z","path":"2017/08/10/cssstudy5/","text":"CSS中的flex布局 Flex布局又名弹性布局，相比float+position布局，具有很强大的灵活性，而且目前已经得到了所有浏览器的兼容。 个人认为flex布局非常灵活好用，所以这里参考了阮一峰老师的flex教程以及NEXT课程中的文档，把flex布局的所有属性知识点自己动手实现一遍并总结。 Flex布局的使用如果想要使用Flex布局，首先需要给容器指定Flex布局。123display: flex;display: inline-flex; //行内元素也可使用display: -webkit-flex //Webkit浏览器内核需要加上前缀 在使用了flex布局之后，float，clear，vertical-align将失效。 Flex布局的基本概念flex布局中，有两个基本概念： 容器（flex container） 项目（flex item） 如图所示（图片来源网络）： 由图可见，容器中有两根主轴： 水平主轴（main axis） 开始位置（main start） 结束位置（main end） 垂直交叉轴（cross axis） 开始位置（cross start） 结束位置（cross end） 在容器中，项目默认沿着主轴排列，单个项目占据主轴空间叫做（main size），占据的交叉轴空间叫做（cross size）。 容器（flex container）的属性容器属性有6个： 1. flex-direction flex-direction决定了主轴的方向，也就是item排列的方向，有4个值： row（默认值）：主轴为水平方向，左端为起点 row-reverse：主轴为水平方向，右端为起点 column：主轴为垂直方向，上沿为起点 column-reverse：主轴为垂直方向，下沿为起点 2. flex-wrap flex-wrap属性是规定当一条轴线排列不下item的时候，该如何换行。（item在默认情况下是按照轴线排列成一条线），有三个值： nowrap（默认值）：不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 3.flex-flow flex-flow是前两种属性的简写方式，可以写成如下形式：123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 4. justify-content justify-content定义了item在主轴上的对齐方式，可能取5个值 flex-start（默认值）：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间间隔都相等 space-around：每个项目两侧的间隔相等。所以项目之间的间隔比项目与边框的间隔大一倍。 5. alien-itemsalien-items定义item在交叉轴上如何对齐（此时交叉轴方向为从上至下），有5个值： flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline：项目的第一行文字的基线对齐这里有一个问题：基线（base line）并不是汉字文字的下端沿，而是英文字母“x”的下端沿。 stretch（默认值）：如果item未设置高度或者设置成auto，将占满整个容器宽度 6.align-contentalign-content定义了多跟轴线的对齐方式，如果item只有一根轴线，该属性不起作用，有6个值： flex-start：与交叉轴的起点对齐 flex-end：与交叉轴的终点对齐 center：与交叉轴的中点对齐 space-between：与交叉轴两端对齐，轴线之间间隔平均分布 space-around：每根轴线两侧的间隔都相等，所以轴线之间的间隔比轴线与边框的间隔大一倍 stretch（默认值）：轴线占满整个交叉轴 item（子元素）的属性item的属性有6个： order：定义item的排列顺序，数值越小排列越靠前，默认为0。例如：将所有item的order属性设置为6、5、4、3、2、11234.item6&#123; order：6&#125;//以此类推 flex-grow：定义item的放大比例，默认为0，也就是如果有剩余空间，也不放大。例如：设置item1的flex-grow属性为2，其余为默认值。123.item1&#123; flex-grow：2;&#125; flex-shrink：定义item的缩小比例，默认为1，也就是空间不足的时候，此item会缩小。例如：给item5设置了flex-shrink属性为0，其他item皆为默认值1，在空间不足的时候，它不缩小。123.item &#123; flex-shrink：0;&#125; flex-basis:定义了在分配多余空间之前，项目占据的株洲空间。然后浏览器根据这个属性来计算主轴是否有多余的空间。默认值为auto，即item本来的大小。例如，给item5设置flex-basis属性为100px：123.item5 &#123; flex-basis：150px;&#125; flex:这个属性是前几种属性的简写，默认值为0 1 auto ，后两个可选。例如： 123item5 &#123; flex : flex: 2 2 10%;&#125; align-self：允许单个item和其他item有不一样的对齐方式，可覆盖align-items属性，默认值为auto，表示继承父元素的align-items属性，如果没有则等同于stretch。和align-items类似，同样有以下几种值： auto flex-start flex-end center baseline stretch 参考资料： 阮一峰Flex布局教程 我的个人博客：http://chronosblog.top我的微信公众号：runtustory","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://chronosblog.top/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"}]},{"title":"CSS中的布局详解笔记（二）","date":"2017-08-07T07:11:23.000Z","path":"2017/08/07/cssstudy4/","text":"CSS中的浮动与定位 display：float 浮动详解在我刚开始学习CSS的时候，看到浮动这个概念，只知道是让一个盒子向左或向右移动，也仅仅在一些简单布局中使用，但后来遇到的许多坑让我意识到，搞清楚浮动究竟是什么还是非常有必要的。 通过查阅网上各种博客文档等，我总结出了浮动的定义：所谓浮动，就是让一个元素脱离标准文档流，漂浮在标准流之上，然后按照指定的方向向左或向右移动，碰到父级边界或者另外一个浮动元素停止。 在前面的总结中已经提到过什么是标准文档流，在布局的时候，浮动脱离标准文档流是非常必要的，比如我们想要让几个块级元素并排显示，这时候用浮动就会显得很方便。 在这篇文章中有关浮动的讲解非常好：CSS浮动 其中作者总结了一个很重要的概念： 假如某个DIV元素A是浮动的，如果A元素的上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边（如果一行放不下这两个元素，那么A元素会被挤到下一行）;如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。 但浮动也会带来一个很严重的问题：浮动元素脱离标准文档流，会导致元素重叠或者父元素的高度塌陷。 这时候就要用到清除浮动。 清除浮动，顾名思义就是为了解决浮动带来的一系列问题，也可以理解为打破横向排列。 在上述的那篇文章中，作者还有一个总结很重要：清除浮动的这个规则，只能影响使用清除的元素本身，不能影响其他元素。 下面来总结几种常用的清除浮动的方式。 1. clear属性例如某个div元素前面的兄弟元素，如果有元素不想受到浮动元素的影响，那么就在这个浮动元素上使用 clear:both即可。 2.给父元素设置高度一般父元素没有设置高度的情况下，子元素浮动之后，父元素会忽略子元素的高度，导致父元素的高度产生塌陷，对于这样的问题，可以给父元素设置高度来解决。但这样做必然要计算好高度值才能够设置，因此除了给父元素设置高度，还可以用其他两种办法： 给最后一个元素设置clear：both 给父元素新建一个BFC 对于第二种方法，在前面的文章中提到过，创建一个BFC的办法有很多，不过在清除浮动中，比较常用的是 overflow:hidden属性。 overflow:hidden是干什么的呢？W3C给出的定义如下： overflow属性规定当内容溢出元素框时发生的事情。其中hidden代表内容会被修剪，并且其余内容是不可见的。 给父元素设置这个样式，不仅可以清除父级内使用float所产生的浮动，比起其他方法来说，显得更简洁明了。 但是好用归好用，为什么设置了这个样式就能够清除浮动？ 查阅了网上的各路大神的文章之后终于有了结论：overflow:hidden的作用是超出元素框部分的内容要被裁剪隐藏，这个裁剪隐藏是根据高度来定的，如果高度的默认值是auto，那么必须先要计算其中浮动元素的高度，也就是其真实高度，再去确定隐藏。overflow：hidden出发了BFC，使得这个元素中的子元素不能影响外部其他元素，所以必须要计算内容的全部高度，才能确定在什么地方开始隐藏。 3.：after方法这种方法是利用：after和：before来在元素内部插入两个元素快来达到清除浮动的效果，原理类似于clear：both。 示例代码如下：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; outer &#123; zoom: 1; &#125; .outer :after &#123; clear: both; content: &apos;.&apos;; display: block; width: 0; height: 0; visibility: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; position属性position属性有4个值。 1.position：static默认值，元素都位于标准文档流中，不会受到top、bottom、left、right的影响。 2.position：relativerelative所产生的定位为相对定位，这种定位是相对于元素本身正常的位置，根据top、right、top、bottom等属性在标准文档流中偏移的位置。 设置相对定位属性的元素，无论如何移动，它原本所占的空间是不会变的，就好像在教室里的座位，无论你怎么移动，你的座位始终在那里占着。 而且，relative不会影响除自身以外其他元素的位置，大小。 3.position：absoluteabsolute所产生的定位又称为绝对定位，这种定位是直接将元素从标准文档流中拿出来，然后再使用top、right、left、bottom等属性来进行定位。绝对定位元素的位置相对于最近的已定位的父亲，如果元素没有已定位的父亲，那么这个元素位置相对于根元素，也就是html。 绝对定位的元素层叠性由z-index属性来控制，值越大，表明优先级越高，距离观察者越接近。 绝对定位元素能够脱离标准文档流，这一点和浮动有着异曲同工之妙，同样会造成父元素的塌陷，同时和浮动元素一样悬浮在标准文档流的上方，还会遮住下面的内容。 还有一些在使用过程当中应当注意的知识点： absolute能让inline元素被“块级”化。 absolute能让元素已有的float失效 相对定位元素一般用来作为绝对定位元素的容器块，也就是口诀：“子绝父相”。 4.position：fixedfixed和absolute基本一致，也完全脱离标准文档流，但关键区别在于fixed永远是根据浏览器确定位置，即使是窗口滚动他也不会动，所以叫做固定定位。 5.background-positionbackground-position一般用来设置背景图像的位置。一般有两个值，如果仅规定了一个值，那么第二个值将默认为center。background-position:top left;还可以用百分比来表示，其中第一个表示水平位置，第二个表示垂直位置：background-position：x% y%;还可以用像素来表示，值表示的意义同上。background-position：50px 100px; 参考资料 腾讯课堂前端NEXT课程资料文档 W3Cschool CSDN网站布局中position的值的用法 我的个人博客：http://chronosblog.top我的微信公众号：runtustory","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://chronosblog.top/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"}]},{"title":"CSS中的布局详解笔记（一）","date":"2017-08-05T03:36:03.000Z","path":"2017/08/05/cssstudy3/","text":"从盒模型入手整理CSS的布局以及知识点详解。 一、盒模型盒模型，顾名思义，是HTML文档中每个元素在渲染的时候都会被描述成一个矩形盒子，盒模型就是表示每个元素盒子所占空间大小的模型。 盒模型主要有四个部分： margin （外边距） border （边框） padding （内边距） content （内容区域） 一般来说，默认盒模型实际占用空间计算模式为： 水平空间大小 = margin（左右）+ border（左右）+ padding（左右）+ width 垂直空间大小 = margin（上下）+ border （上下）+ padding （上下）+height 因此， 一个元素的实际大小为：border + padding + width/height 在CSS中，名为box-sizing的属性可以改变元素宽高的计算方式。 box-sizing有两个常用的取值： content-box border-boxcontent-box为默认值，实际宽高为上述元素实际大小的计算方式。border-box则是一个元素设置的width和height，不包含其他的。 二、视觉格式化模型元素能够被渲染成一个又一个盒子，那么这些盒子的位置在页面中又是如何摆放的呢？ 在默认情况下，盒子是按照元素在HTML中的先后位置从左至右从上至下一个接着一个排列放置。 但此时也分为两种情况，有的盒子呈水平排列，有的盒子却占满整个一行。这是因为不同的盒子，使用的是不同的格式化上下文来布局。 格式化上下文常见的有两种： 块格式化上下文（BFC） 行内格式化上下文（IFC） 当元素的display值为block、list-item、table、flex、grid时，它是块级元素，每个块级元素至少生成一个块级盒，块级盒参与BFC，被渲染成完整的一个新行。 W3C对于BFC的定义是： 浮动元素和绝对定位元素，非块极盒子的块级容器，以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的块级格式化上下文。在一个块级格式化上下文里，盒子从包含块的顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin来决定的，两个相邻的块级盒子的垂直外边距会发生叠加。在块级格式化上下文中，每一个盒子的左外边缘会触碰到容器的左边缘（对于从右到左的格式来说，则会触碰到右边缘），即使存在浮动也是如此，除非这个盒子创建一个新的块级格式化上下文。 总结一下BFC的特性： 内部的Box会在垂直方向，从顶部开始一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加。 每个元素的margin box的左边，与包含块border box的左边相接触，即使存在浮动也是如此。 BFC的区域不会与float box叠加 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。 计算BFC的高度时，浮动元素也参与计算。 当元素的display值为inline、inline-block、inline-table、inline-flex、inline-grid时，它是行内级元素，行内级元素生成行内级盒，参与IFC，被渲染为水平排列，直到当行被占满然后换行。 总结IFC的渲染规则： 盒子一个接一个地水平摆放，当容器宽度不够时就会换行。 在水平方向上，这些盒的外边距，边框，内边距所占用的空间都会被计算，但行内和的垂直border，padding，margin都会撑开行盒的高度。 在垂直方向上，这些盒可能会以不同形式来对齐，可通过vertical-align来设置，默认对齐为baseline 每一行将生成一个行盒，包括该行所有的盒子，行盒的宽度是由包含块和存在的浮动来决定 行盒一般左右边都贴近其包含块，但是会因为浮动和的存在而发生变化，浮动盒会位于包含块边缘与行盒边缘之间，这样行盒的可用宽度就小于包含块的宽度 当所有盒的总宽度小于行盒的宽度，那么行盒中的水平方向排版有text-align来决定 当所有盒的总宽度超过一个行盒时，就会形成多个行盒，多个行盒互相之间垂直方向不能分离，不能重叠 当一个行内盒超过行盒的宽度时，它会被分割成多个盒，这些盒被分布在多个行盒里，如果一个行内盒不能被分割，那么这个行内盒将溢出这个行盒 行盒的高度由内部元素中实际高度最高的元素计算出来，每个行盒的高度由于内容不一样，所以高度也可能不一样 在一个行盒中，当他包含的内部容器的高度小于行盒的高度的时候，内部容器的垂直位置可由自己的vertical-align属性来确定 在IFC中，是不能存在块级元素的，如果将块级元素放入IFC，那么会被破坏成BFC，而块级元素前的元素或文本和块级元素后的元素或文本将会各自自动产生一个匿名块盒将其包围。 三、一些易混淆的概念块元素与块级元素块级元素：块级元素是那些视觉上会被格式化成块状的元素，也就是会换新行的元素。块元素：块元素是display属性值为block的元素，他应该是块级元素的一个子集。 行内元素与行内及元素行内级元素：行内级元素是不会为自身内容形成新的块，而让内容分布在多行中的元素。行内元素：行内元素仅仅是display值为inline的元素，是行内及元素的一个子集。 block，inline，inline-blockblock和inline这里不再赘述，重点说一下inline-block：inline-block是将元素呈现为inline，但元素的内容却又作为block呈现，既具有block的宽高特性，又具有inline的同行特性。 参考资料： 腾讯课堂前端NEXT课程文档——视觉格式化模型","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://chronosblog.top/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"}]},{"title":"总结CSS中的单位","date":"2017-08-03T12:00:41.000Z","path":"2017/08/03/cssstudy2/","text":"总结CSS中的单位以及用法。 CSS中的单位pxpx（像素）是CSS中最为常用的一种单位，传统上一个像素对应计算机屏幕上的一个点，对于高清屏则对应更多。 %百分比也较为常用。其中对font-size设置百分比值时，是以浏览器默认字体大小16px为参照计算的。 emem是一种计算方式为相对于父元素的字体大小的单位，1em等于父元素设置的字体大小，如果父元素没有设置字体大小，则继续往父元素查找，直到有设置大小的，若都没有设置大小，则使用浏览器默认大小。 CSS中常用属性里使用em这样计算方式的属性有： border width height padding margin line-height 例如：1234p&#123;font-size: 16px;padding: 1.5em /*此处1.5em=1.5*16px*/&#125; remrem和em类似，也是相对单位。rem的参照物是根元素HTML的font-size，因此，如果改变HTML的font-size值，那么所有使用的rem单位大小都会随着改变，适用于移动端。（不支持IE8以下） v系单位v系单位常用于移动端，是基于浏览器用来显示内容的区域大小，也就是视窗大小来就算的。具体分为4个： vw：基于视窗的宽度计算，1vw等于视窗宽度的百分之一 vh：基于视窗的高度计算，1vh等于视窗高度的百分之一 vmin：基于vw和vh中最小值来计算，1vmin等于最小值的百分之一 vmax：基于vw和vh中最大值来计算，1vmax等于最大值的百分之一 单位运算CSS中可以使用CSS函数calc()来通过计算确定一个属性的值。例如：1width:calc(100%-80px);","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://chronosblog.top/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"}]},{"title":"总结CSS基础中的一些小坑","date":"2017-08-01T15:45:41.000Z","path":"2017/08/01/cssstudy1/","text":"CSS虽然很有趣，入门也容易，但对于前端菜鸟、初学者来说，还是有一些小坑是无法避免的，这些小坑相对而言更需要去积累和理解，也是比较容易忽略的一些问题，以至于学到后来，因为没有搞定这些小坑而延伸出许多“大坑”，相当影响学习效率。 一、CSS选择器CSS中的选择器大体分为五大类： 基本选择器 关系选择器 伪类选择器 伪元素选择器 属性选择器 这五大类里每一类又分别有很多类型的选择器，可以说是一个庞大的“选择器”家族。然而，在实际使用过程当中，用的最多的其实也就那么几种而已，比如标签选择器，类选择器，ID选择器等。那么，我们在需要使用选择器的时候，优先考虑的究竟是什么呢？这时候有的同学肯定会疑惑，难道不是哪个更方便就用哪个吗？ 其实不然。我们从零学习前端开发，最终的目标实际上是做一个合格的开发者，所以优先考虑的肯定是“合格”二字。所以，在使用选择器的时候，我们要考虑选择器优化这个概念。 对于浏览器来说，解析每种选择器所耗费的时间并不一样，那么如何才能写出最优选择器呢？ (引用内容来源于IMWeb的技术文章) 根据网站效率专家Steve Souders指出，各种CSS选择器的效率由高到低排序如下： id选择器 类选择器 标签选择器 相邻选择器 子选择器 后代选择器 通配符选择器 属性选择器 伪类选择器 假如现在需要对一个p元素来使用选择器： &lt;p id=&quot;text&quot; class=&quot;red&quot;&gt;这是一个段落&lt;p&gt; 我们可以通过很多方法选中它，标签选择器，类选择器，id选择器都能做到，但按照执行效率来说，id选择器是最佳的，其次是类选择器，然后是元素选择，最后才是属性选择器。 这里有一个小例子，作为一个前端新手，我刚开始练习CSS的时候，习惯在例子中使用了通用选择器“*”来清除margin和padding： *{margin: 0; padding: 0;} 直到后来，看到别人清除浏览器默认样式的时候都写一大长串，甚至引入一个专门的CSS文件来用于清除默认样式，我十分不解，用通用选择器岂不是更方便？ 后来才明白，这样做反而是最没有效率的！原因在于浏览器匹配文档中所有的元素后会分别向上逐级匹配，一直到文档的根节点才作罢，这样匹配的开销是非常大的。所以，应当避免使用通用选择器。 还有一个问题很关键：浏览器又是如何识别你写的选择器的呢？ 实际上，浏览器读取你的选择器，遵循的原则是从选择器的右边到左边读取。也就是说，顺序是从右到左。 所以当你给一个元素写了相当多的选择器，浏览器会从右到左来寻找，显然路径链会影响效率。因此，建议选择器的层级最多不要超过四层。 综上所述，在使用选择器的时候，其实要做一个综合考虑，每一次都用最优解来使用，这样才能提高代码的效率。 二、CSS优先级CSS中的优先级大概如下： ！important &gt; style &gt; id选择器 &gt; 类选择器 &gt; 元素选择器 &gt; “*” &gt; 浏览器默认 &gt; 继承 这样的优先级比较方式比较笼统，所以还有一种比较普遍的简化方式： 我们把每一个选择器都用一个数字（权重值）来表示，元素选择器用个位数，类选择器用十位数，id选择器用百位数。 选择器 权重值 id选择器 100 类选择器 10 元素选择器 1 于是，权重的计算我们可以总结如下图所示： 其中，没选中代表的就是继承来的属性。 知道了选择器的优先级，那么元素最终的样式究竟是如何得出的呢？ 我们知道，一个元素的样式来源有： 继承自父级元素的样式 浏览器的默认样式 元素自己声明的样式 最终应用的样式就是通过一系列复杂的计算体系而得到的。而这里面有几个值需要注意。 应用值（used value）、初始值（initial value）、（inherit value）最终应用的样式称之为应用值，如果一个元素声明了样式，那么应用值就是这个声明的样式，但如果没有声明，那应用值又是什么？ 这里还包括了两个特殊的值：继承值和初始值。 一个属性默认是继承的，我们得到的它的父元素的同属性的应用值就叫做继承值。如果属性是默认不继承的，那么就会有一个初始值，这个初始值实际上就是一个默认的值，比如width的初始值是auto。 三、CSS重置有关CSS重置之前已经提到过，就是清除浏览器默认样式。 对于不同的浏览器，其默认样式都是不一样的，而且默认样式有时候实际上就如同画蛇添足一般，清除是非常必要的。 CSS重置分为两种，一种是纠正重置，一种是清零重置 纠正重置，就如字面意思，因为浏览器默认样式有差异的缘故，我们需要来消除这些差异，让页面在不同的浏览器中看起来一致。开源的normalize.css就可以做到这一点，这里不再赘述。 清零重置，就是彻底的去除默认样式，这个可以根据自己的需求来写，也可以参考一些文档，例如：Eric Meyer’s Reset CSS 2.0 我的个人Blog：chronosblog.top我的微信公众号：runtustory","categories":[{"name":"编程","slug":"编程","permalink":"http://chronosblog.top/categories/编程/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://chronosblog.top/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://chronosblog.top/tags/前端/"}]},{"title":"《色戒》：引刀成一快 不负少年头","date":"2017-06-26T07:33:06.000Z","path":"2017/06/26/movie-1/","text":"《色戒》：引刀成一快 不负少年头 色戒是一部很好的电影。 初次知道这片子，还是因为它的激情床戏。殊不知，这部片子用心看，情欲戏就显得一点儿也不色情了。 何谓色|戒？这两个字在片名中就是分开的，其所表达的意思也是一样。 色，代表色欲，色相。戒，代表戒指，戒备，戒心。 这部电影，讲的就是一个关于色和戒的悲剧故事。 影片开头，四个女人在打麻将。手里摸着牌，嘴里仍然不停地唠着磕，实则四人都是在互相套路。只不过麦太太与其他三人的目的与动机不同，因此整个片子下来，麦太太打牌的水平都没有长进多少。 影片讲述的故事很简单，也不简单。六个青年大学生谋划了一场刺杀汪伪特务头目易先生的行动，让青年女学生王佳芝扮演阔太太打入易先生家中来创造机会，六个人皆是爱国青年，而这个组织的核心人物，除了假扮麦太太的王佳芝之外，还有一个邝裕民。 而他和王佳芝，是互相有些爱慕的。 但爱慕邝裕民的，还有六人中的赖秀金。 再后来，因为王佳芝还是处子之身，为了避免易先生怀疑，其余五人商量先让王佳芝经历男女之事。 这个时候，和王佳芝互相看对眼的邝裕民应该挺身而出，但最终的结果却是让梁润生来完成，理由非常荒诞，竟是他嫖过，有经验。 男女之事，两个互相喜欢的人自己慢慢摸索不可以么？ 看赖秀金的表情和众人的反应，显然都不是那种性知识缺乏到以为接吻都能怀孕的地步。 邝裕民似乎有些郁闷的在阳台上抽烟，他此时此刻没有站出来，我想是因为他心里的“爱国主义”在作祟。他作为这个组织的领导，尤其是正在行动当中，一切都得以行动为重，这种革命者崇高的荣誉感以及责任感在他的心中，远远大于对王佳芝那一丝丝朦胧的好感。 而且，邝裕民并不懂王佳芝。 到了后来，有了诸多经历的两人再次执行这个任务，邝裕民才发现王佳芝是那样的迷人。因此他吻了王佳芝。 但他仍然不懂王佳芝，一点儿也不懂。 王佳芝肩负重担，戴着面具执行着任务，而易先生，也像是一条蛇一样，除了在生理上完全占有了王佳芝 ，就连她的心，也正在一点一点地往里钻。 易先生是一个时时刻刻都活在虚幻和黑暗中的人，或许他每天早晨醒来的第一件事，就是确定自己是否还活着，接着还要花一秒钟的时间记起自己是谁。 活在黑暗中的人往往都不喜欢黑暗，他们总是活的很小心翼翼，时时刻刻警觉，警戒，生怕一个不小心，下一秒就丢了性命。 王佳芝的出现，似乎给了易先生一点点亮光。 两个人相逢，相互试探，相互套路，王佳芝和易先生之间，是一场没有赢家的战争。很残酷，也很激烈。残酷到要将王佳芝这个人硬生生的撕裂。 影片的重头戏，便是王佳芝与易先生的三场床戏。 第一场，在相互的试探之后，易先生以暴虐的方式征服王佳芝，那般激烈的云雨，是易先生对内心的情欲和征服欲过度的表达。但事后王佳芝嘴角洋溢的那一抹玩味的笑容，恰恰说明这场博弈真正的赢家并不是易先生。 但，这才刚刚开始。 第二场。易先生和王佳芝偷情。 两个人皆是沦陷在了性爱当中，在爱与痛的边缘里享受着如潮水般的快感，两种无比极端的滋味混淆在一起，使得这样的压抑只能用忘我的疯狂来释放。 王佳芝对易先生的感情，也在此时展露无余。 第三场。 有了前两次的铺垫，第三场绝对是一个高潮部分。 这一次，两个人的灵魂真正交织在了一起。 王佳芝将枕头捂在了易先生的脸上，将易先生置于黑暗当中，他的表情既享受，又挣扎。这是理性与感性的博弈，当灵魂出于这两者之间的边缘处，那种挣扎的感觉，以及对于未知的惶恐与迷惘，都在这一刻展现的淋漓尽致。 处在崩溃的边缘，则需要一个宣泄口，王佳芝的眼泪就代表这样的一个意义。内心的挣扎与生理上的快感双重夹击，那样难以言表的感觉只能通过眼泪来宣泄。 王佳芝是真正爱上了易先生，但易先生呢，他到底爱不爱王佳芝？ 爱。 但爱的还不够。 很显然，对于易先生来说，还有比对王佳芝的爱更加重要的东西。 王佳芝爱易先生如浩瀚星辰，易先生爱王佳芝则只有一轮圆月。 这首《天涯歌女》不要说易先生感动到掉泪，就连我这个局外人都无比动容。 王佳芝面对这个自己无论如何都不能去爱，但又彻彻底底地爱上了的男人，那种折磨，真的无比之残忍。 有那么一瞬间，我真的希望影片到易先生送给王佳芝鸽子蛋这里就结束。这颗鸽子蛋，我想一般的女人都无法抵抗它的力量。不仅仅是因为它是鸽子蛋这么简单。 易先生是爱王佳芝的，虽然没有王佳芝爱他那么爱。但是，他真的从头到尾都没有怀疑过王佳芝吗？ 影片中有几个细节。 易先生约王佳芝到一家很安静的餐厅吃饭，王佳芝的口红粘了杯子。身为阔太太的王佳芝，不应该用这种劣质的口红。此为第一点。 在两人云雨交欢当中，王佳芝看了一眼挂在墙上的枪，而易先生显然也发现了王佳芝的这一小小举动。在那般情况之下，王佳芝分神用短短两三秒的时间看了一眼挂在墙上的枪，作为一向谨慎的易先生，肯定也会生出一丝疑虑，哪怕只有一瞬间。此为第二处。 王佳芝的感情战胜了理智，开口让易先生快走，易先生先是疑惑了一秒，随即便换上了惊恐的表情，以最快的速度溜之大吉。 他能够在这样短的时间内明白王佳芝表达的意思，说明他对王佳芝不是完全的信任，对王佳芝的爱也没有到抹去戒备之心的地步。 影片中，最令我动容的，实际上还是易先生走了之后的这段戏。 看着橱窗内华贵的衣服，王佳芝的内心终于释然，任务结束了，一切终于结束了。她再也不是麦太太了，她以为自己彻底地从这个角色当中脱离，但灵魂里却又有怎么抹也抹不掉的痕迹。她内心五味杂陈的望着镜面反射出的世界，自己似乎就像是一个没有了身体的鬼魂。 快活的车夫脸上洋溢着希望的笑容，多么像是没有参加行动之前的王佳芝，充满着活力，朝气蓬勃。而就是这样一辆充满希望的黄包车，将王佳芝拉向了死亡的沈渊。这象征着王佳芝并不后悔自己的决定，在王佳芝和麦太太两个身份当中，她付出巨大的代价选择了后者。 爱，就是这样令人盲目。 还有这颗一开始就准备好的药丸，王佳芝没有吃下去。 既然她选择了继续做麦太太，那么，死在自己的爱人手里，或许才是最好的归宿。 但实际上，镜子中的王佳芝，镜子外的麦太太，她早已分不清楚了，她唯一能做的，就是听自己内心的声音，跟着那个声音做出选择。 得知真相之后的易先生是那样的无可奈何，但他又何尝不是一个被人操控着的提线木偶，时时刻刻活在黑暗中，戴着假面，一切都不受他的控制。 而他的秘书，则是代表着更高层次的操控者。虽然影片中表现的很隐晦。 秘书早就得知邝裕民六人的底细，但却到了最后才告知易先生。在那样一个时代背景之下，易先生又是那样特殊的一个身份，或许在现实面前，爱情的确虚幻了一些。 结尾枪决处的邝裕民只能用诧异，不解的眼神质问王佳芝，临死之前，他怎么也说不出“你这个叛徒”这种言语，因为他完全不理解王佳芝的行为，或许此时，他才明白，自己根本一点儿也不懂王佳芝。 完。 PS：原来的图床挂了，所以图片都找不到了……其他文章如果图片挂了，都是一样的原因。","categories":[{"name":"杂文","slug":"杂文","permalink":"http://chronosblog.top/categories/杂文/"}],"tags":[{"name":"影评","slug":"影评","permalink":"http://chronosblog.top/tags/影评/"}]},{"title":"《意识保镖》","date":"2016-06-18T12:24:25.000Z","path":"2016/06/18/novel-2/","text":"一。 蓝瘦香菇酒吧。 陈一靠在吧台旁，眼神肆意的打量着女服务员姣好的脸蛋，微笑道：“美女，给我一个空杯子。” 虽然个头不高，长相稚嫩，穿着也邋遢褴褛，但陈一的身上似乎带着一股子不属于这个年龄的沧桑味道，但凡看到他，便很难让人移开目光。 酒吧内往往鱼龙混杂，不论是花花公子猎艳，还是文艺女青年自我感伤，不良少年和社会青年寻衅滋事，酒鬼喝饱了不给钱，一切皆有可能发生。 女服务员像是对什么都司空见惯，面无表情地拿起一个空的玻璃杯递给陈一。没有人会发现，她拿起杯子的那一瞬间，眼神隐隐有一秒钟的空洞。 陈一接过杯子，从裤子口袋中拿出两个鸡蛋，拿起一个单手轻轻在杯口敲了敲，“咔哒”一声，蛋壳从中间精准的碎裂出一条缝隙，蛋清夹杂着蛋黄流入杯中。 打完两个鸡蛋，陈一对于旁人的眼神视若无睹，直接把手指头伸进杯子里胡乱地搅了搅，然后仰起头一饮而尽。 杯中明明是蛋清和蛋黄的混合物，却像是被陈一喝出了酒的味道，喝光之后，陈一还一脸陶醉地砸了咂嘴。 “味道怎么样？”女服务员忽然问道。 “还不错。”陈一下意识地点了点头。话音刚落，他像是察觉到了什么，猛地一个转身准备逃跑，谁料手臂却被女服务员钳子般的双手紧紧抓住，无法动弹。 当看到女服务员仿若变了一个人般，目光呆滞，表情阴冷，嘴上还噙着玩味的笑容，陈一心脏猛的一沉。 是追杀者！ 这时候，周围其他客人也和女服务员一样，像是中了邪一般，眼神空洞表情古怪，迅速朝着陈一围了过来！ 陈一来不及多想，猛地将另一只手中的杯子砸向了女服务员的面门，趁着对方躲闪的空隙，陈一猛地甩开被钳住的手臂，瘦小的身躯如同一只猎豹，猛地朝酒吧后门狂奔。 酒吧的后门直通一条小巷子，陈一一边跑，脑子也同时飞速地转动。 他们是怎么找到自己的？究竟是哪里出了问题？ 二。 陈一的身份是一名意识保镖。 在这个网络无比发达的信息化时代，整个世界如同被信息的大网覆盖，化作一副恢宏浩瀚的地图，依靠网络，在这地图上的每一个点都能够彼此链接交互。 于是，便诞生了陈一这样的人，他们有一种特殊的本领——意识可以进入网络，能够在网络世界中穿梭遨游，来去自如。 如果把人的大脑比喻成一个巨大无比的数据库，那么陈一这样的人就是一把万能钥匙，不仅能够获得自身数据库的最高权限，通过网络，还能够侵入别人的数据库中肆意妄为。 这样的人，行内统一称呼为“漏洞”。 因此，间谍行业依靠先进的科技又向前迈出了一大步，“漏洞”逐渐增多，意识保镖和意识黑客也应运而生。 意识黑客侵入他人大脑盗取记忆，而意识保镖就是保护雇主的安全，严防意识黑客的侵入。 陈一是一名孤儿，从小在孤儿院长大，十二岁那年被神秘组织以领养为借口，在毫不知情的情况下被改造成了“漏洞”。 “漏洞”在改造成功之后，还要经过极其残酷的训练手段才能够成为一名合格的意识保镖。顾名思义，对于组织来说，合格的意识保镖首先一定要对组织百分百的忠心，无条件地服从组织的任何一项指令，像是一具没有思想的人型机器。 陈一是这方面的天才，在成为“漏洞”之后，陈一的天赋很快便不经意间显现了出来，在进入组织第五年的时候，陈一就能轻松破解组织内实力最强的意识保镖设下的七道脑域防火墙，于是，陈一成为了组织内的重点培养对象，意识保镖中的“王牌”成员。 这个组织，就如同潜伏在黑暗中的一具庞然大物，它以最残酷的手段来折磨你，还要让你病态地痴迷这一切，并发自内心地臣服于它。这样复杂的情感几乎折磨着任何一个“漏洞”，但他们没有一个人想摆脱这一切，不是他们不想，而是他们不敢想。 但陈一却是个例外，他不仅敢想，而且还成功地逃了出来。 进入组织的第八年，在执行一次任务的过程中，陈一机缘巧合之下得知，这次任务结束，他将要被组织抹杀！ 多年来积压在心底的血性终于厚积薄发，让陈一做出了逃跑这个疯狂地决定。 他很想回家看看，回到那个真正属于他的地方，孤儿院才是他的家。 家是陈一心里唯一的执念，家中有院长，有三儿，他们是陈一在这个世界上唯一的亲人，唯一在乎的人。 家，是陈一最后的希望。 三。 陈一的逃命之旅很是艰辛，他给自己的脑域增加了十重防御，每一重的程序算法都复杂至极，即便是依靠超级计算机来破解，也需要尝试七天以上。在路上，陈一确定自己没有留下任何蛛丝马迹。 可即便这样，组织还是能够找到陈一，算上刚才的那次追杀，已经是第五次了。 这不禁令陈一有些心灰意冷，难道自己终究还是逃不过命运的枷锁么？ 想起曾经在沙漠中认识的朋友段弛曾对他说过，人的一生可以没有追求，但是永远都不能放弃希望。 段弛是个很有味道的中年男人，他像是从不被这个世界所束缚，按照他自己的话来说，这个月他漫步在撒哈拉沙漠，下个月，说不定已经去一睹法老金字塔的风采了。 在确定安全之后，又重新更换了自己脑域防御系统的程序算法，陈一这才狠狠地松了口气，这次又勉强逃过一劫。 去车站买了一张邻城的车票，坐在大巴车上，陈一的眼神终于恢复了平静。 陈一紧握背包上挂着的那一道平安符，这还是段弛送给他的礼物，据说是他上一任女友送给他的。他女友的原话是，向段弛这样的男人，既然拴不住他的心，那就放他走吧，只要各自平安喜乐，得偿所愿就好。 一想起段弛，陈一总是不经意间就会露出笑容。这个有趣的人，不知为何总能给他一种既熟悉又陌生的奇怪感觉。 抬头看了一眼车窗外，场景不断地随着车的行走而变换，如同一幕无声地电影。 终于，就快要到家了。陈一这样感叹道。 四。 陈一边上坐着一个穿着格子衬衫，鼻梁上架着一副眼睛的小青年，看样子像是个学生。 自从上车后，他的眼睛就一直有意无意地瞟向陈一，把陈一看的心里直发毛。 见陈一发现了自己的举动，小青年嘿嘿一笑，主动凑上前朝陈一打招呼道：“哎，哥们，你也是学生？” 陈一面无表情地摇摇头。 看到陈一一副不愿意搭理自己的样子，小青年忽然凑到陈一的耳边，小声说道：“意识保镖？” 听到这四个字，陈一吓了一大跳，条件反射地抓起背包，满脸警惕地盯着面前地小青年，时刻准备逃跑。 不会吧？这么快又追上来了？陈一心中哀嚎道。 “你先别激动！”小青年连忙按住了陈一。“我没有恶意的。” 随即，小青年四下打量了一番，这才一脸兴奋地低声问道：“我说，你是在执行任务吧？” 看这小青年的样子，似乎不像是追杀者。陈一冷冷地盯着他，没有回答问题，但心里稍稍松了些，恢复了一丝冷静。 “我叫梁孝，在Ｂ市上大学，专业就是意识潜入这个新兴领域。”梁孝主动伸出手来，见陈一没有和他握手的意思，尴尬地笑了笑，直接抓住陈一的手握了握。 “我平时也喜欢捣鼓一些小玩意儿，刚才无意间发现你的脑电波频率有些特殊，我猜想，你一定是意识保镖了！” 随即，梁孝从背包里拿出一个类似手电筒地玩意儿，还有一根线连接在梁孝的平板电脑上。 这时陈一才恍然大悟，不过他有些好奇，自己的脑电波模拟的频率可是随时随刻都在变化，就连组织里的追杀者破解都需要一定时间，梁孝手里的这个玩意儿这么厉害？竟然能轻易让梁孝猜到自己的身份。 “你想多了，我不是什么意识保镖。”陈一淡淡道。实际上他也没有说错，现在的陈一，的确已经不是意识保镖了。 梁孝一脸“我了解”的样子，摆摆手道：“没关系。你放心，我绝对会帮你保密的。” “……”陈一无言。 “你是不知道，我当初报这个专业，就是为了当意识保镖，且不说这个职业前途远大，就是以后泡妞也派的上用场啊！俗话说女人心，海底针，不过在意识保镖的面前，不管你是加勒比海还是印度洋，我都能给你捞出来！”梁孝滔滔不绝地自说自话，他似乎也看出了陈一的不善言辞，但也并不在意。 陈一心中冷笑，意识保镖前途远大？真正的意识保镖那都是从地狱中走出来，永远过着人不人鬼不鬼的日子，这种生活岂是普通人能够承受的了的？ 但陈一也看得出，梁孝只是一个不知内情的人，错误地曲解了意识保镖这个职业，这倒也情有可原。因为，曾几何时，自己不也是抱有这种想法的么？ 之后，梁孝还亲自给陈一示范了他研究出来的小玩意儿，陈一发现，这家伙还真是个天才，这套装置几乎能够当做山寨版的“漏洞”，潜入一般人的意识倒还真不是什么难事。 汽车中途路过Ｂ市的时候，梁孝下了车。下车之前，陈一暗中存储了梁孝的脑电波频率，梁孝也热心的留了电话号码，表示以后有机会用的上他的话，一定联系。 陈一透过车窗打量着梁孝的背影，他忽然希望梁孝永远都不要踏入这个泥潭，也永远都不要得知真相。 五。 站在孤儿院的门口，陈一内心感慨万千。 回来了。终于到家了！ 这里依旧还是记忆中的样子，只不过，门口的那颗树却长大了，枝叶在秋风的肆虐之下仍然还挂着几片绿意，漫地金黄色的落叶无规则的洒落在门前的地面上，即便这样，陈一仍然感觉得到它很健康。 看来，三儿有好好照顾它。 正这样想着，一道亲切熟悉的声音响彻在耳旁，这一刹那间，陈一的眼眶湿润了。 “小一？是你吗？” 看到不远处院长的身影，陈一抬抬头努力不让泪水流出，脸上竭力微笑着狠狠点头。 “我回来了。” 院长的两鬓已经斑白，脸上也刻满了岁月的痕迹，他走过来拍了拍陈一的肩膀，声音有些沙哑：“长高了。回来了就好，回来了就好！” 陈一扔下背包，狠狠地拥抱了院长。面前这个亦师亦父的人，无论什么时候，他宽厚的胸膛总能给陈一一种安全感，陈一紧绷了许久的神经也在这一瞬间彻底松懈。 罗三听到动静，也冲了出来，看到陈一之后，一瞬间也微微有些失神。 “三儿！”陈一大喊了一声，冲上去紧紧拥抱住罗三。 罗三有些木讷地抱住陈一，脸上充满了难以置信的神色。 这么多年过去，罗三也长大了，虽然比陈一小几个月，但一直比陈一长得快，个头一直高陈一半个脑袋，现在更是成了一米八几的魁梧壮汉。 刚刚反应过来的罗三忽然狠狠抓住陈一的肩膀，上下好好打量了一番面前的这个小个子，语气有些复杂道：“你怎么这个时候跑回来了！” 陈一微微一愣，随即想起罗三和院长可能还不知道自己目前的情况，于是道：“我待会再给你们解释，先进去吧？” 院长道：“三儿，你先带小一进屋去吧，我去给你们做饭，今天下午包饺子。” 一听是自己最爱吃的饺子，陈一不禁喜笑颜开，搂着罗三的肩膀便朝屋里走去。 “门口那棵树跟你一样，个头窜的老高了，我就知道你肯定会好好照顾他的。” 罗三不知怎么了，强笑了一声道：“那是当然。” 进屋坐下，罗三给陈一倒了杯水，然后坐在陈一的旁边。 “其他人呢？”陈一喝了口水，问道。自打进了孤儿院，他发现这里变得有些冷清，除了院长和罗三，好像没有其他人的样子。 “宁九带小孩儿们去山上玩了，大概明天回来。”罗三回答。 “宁九？哈哈！”陈一笑道：“你的那个跟屁虫啊，记得小时候我们没少欺负他。” “是啊。”罗三点点头。“他也是我们的好兄弟。” 随即，罗三有些欲言又止地样子，像是做出很大决定一般开口道：“小一……这些年来，你过得好吗？” “我？”陈一闻言无奈地笑了笑。“还好吧，你们呢？” “也都还好。”罗三回答。 陈一微微皱眉，虽然知道罗三是个闷葫芦，但不知怎的，他感觉罗三有种说不上来的不对劲儿。 一时间，屋内的气氛陷入了沉默，陈一正在思索着如何解释自己被领养之后这么多年都没有回来看看的原因，他不打算将自己的事告诉院长和三儿，更没有打算久待，他不想因为自己而连累到孤儿院。 吃完这顿晚饭，明天一早就走。陈一心中决定。 六。 热气腾腾地饺子端上了桌，陈一配好蘸料，迫不及待地拿起筷子吃了起来。 这顿饺子他想了足足八年时间，一想起来便直流口水。如今，能够再一次吃到院长包的饺子，陈一心中很是满足。 看着陈一狼吞虎咽的样子，罗三眼神复杂，不紧不慢地吃着。倒是院长，满脸欣慰的看着陈一，叮嘱道：“慢点吃，小心别烫着。” “香啊！” 陈一吃得满嘴流油，不知怎的心头忽然涌上一股辛酸之感，眼泪再也忍不住，洪水般涌了出来。 罗三见陈一这般模样，也是狠狠地握了握拳。 “你这孩子，好好的怎么哭起来了。”院长嗔怪道，微微叹了口气，拿起纸巾递给陈一。 许久，陈一平复了心情，深呼吸了一口，这才说道：“没事儿！就是挺想饺子的。” “这还不简单？”院长道。“既然回来了，我以后天天包给你吃！” 陈一闻言笑着点了点头，再次埋头狂吃了起来。 他在贪婪地享受着在家的每一分每一秒，吃饺子的时候，陈一嚼得不能在碎之后，才恋恋不舍地咽了下去。 八年来，今天是陈一感到最幸福的一天了。只有今天，陈一才感觉到自己是一个活生生的人！一个有喜怒哀乐，有感情，有血有肉的人！ 饭后，院长拉着陈一闲聊了一会儿，按照事先编好的理由，陈一倒也没有露馅，直到十点多钟，院长面露疲色，这才安排陈一去休息。 躺在床上，陈一久久不能入眠，他的脑袋疯狂地运转着，思索如何解开目前这个死局的办法。 他回来了，虽然陈一心中满是决然，理智也告诉他不能久留，但陈一真的不想走，家的力量让陈一对这里无比眷恋，陈一又不得不走。 良久，他还是没有想出一丁点儿办法。为了不连累孤儿院，他只有走！继续过上那精神时刻紧绷，九死一生的日子，他不知道自己还有多少个下一次，在面对组织这个庞然大物，总有一天陈一会落在他们的手上。 这一刻，陈一真希望时间能够永远固定在这一天。 忽然，敏锐的神经让他察觉到了一丝不对劲，陈一浑身的肌肉瞬间紧绷，眼神犀利的盯着门口，喝道：“谁！” “嘎吱。” 门被推开，罗三的身影出现在了门口。 “三儿？”陈一长出了口气，疑惑道：“你怎么来了？” 罗三的表情很是僵硬，看得出来，他在门口犹豫了很久。 “我来看看你。”罗三道。 陈一笑了笑，道：“这么晚了，你还没睡？你明天不还是能看到我，我说，你有这么想我吗？” 罗三沉吟了片刻，问道：“你确定，明天我还能看到你？” 陈一闻言心中一凛，罗三难道知道了自己明天要走的事情？不可能！ “先进来吧。”陈一下床让罗三进屋，顺便关好了门。 “小一。”罗三坐在床上，直视陈一的眼睛。“你明天一早就走，对不对？” 陈一微微愕然，随即强笑道：“你瞎说什么呢？我去哪儿？” “别瞒我了。”罗三叹了口气，道。“你这次就不该回来。” 七。 罗三的话像是一记重锤砸在了陈一的心里，他继续追问下去，罗三却又打死都不肯说。 他的话到底是什么意思？陈一思索着，眼前仿佛被一层迷雾笼罩，愈发的看不透这一切。 陈一又躺下，不知何时便沉沉睡去，他做了一个很长很长的梦，梦见自己从组织里逃出来，在轮船的集装箱内和一群难民偷渡，在沙漠中盯着火辣的太阳步履蹒跚，嘴唇干裂，一次又一次地被组织追杀，偷袭，过往的一幕又一幕如同电影一般呈现在眼前，让他有种歇斯底里想要逃离这个世界的冲动。 终于，他回到了家，回到了孤儿院，院长亲切的面庞，罗三魁梧的身影，院子门口的那棵树，一切的一切都让他感觉到心安。 可是忽然，院长的脸逐渐扭曲，模糊，幻化成了一个没有五官的无面人，凛然的杀机瞬间弥漫周围，接着，罗三的脸也同样幻化成了无面人，越来越多的无面人出现了，他们不约而同地围向陈一，手中拿着沾满鲜血的刀子，从不同的方向朝着陈一狠狠刺来！ “啊！！” 陈一惊醒，冷汗浸透衣衫，但眼前忽然猛地一亮，让他一时有些睁不开眼睛。 而且，让陈一感到恐慌地是，他的四肢竟然被死死地固定住，丝毫不能动弹！ 是追杀者吗？ 难道……我已经落入了他们的手中？ 陈一的心砰砰直跳，等眼睛适应了眼前的强光，陈一缓缓地睁开眼睛，当他看到映入眼前的第一幕时，瞳孔瞬间放大，双目圆瞪，布满血丝！ 他看到的不是什么妖魔鬼怪，更不是追杀者无面人，而是院长那张苍老而又冷峻的脸！ 陈一的脑袋上布满了密密麻麻的电极线，熟悉这一切的陈一明白，自己的意识正在被强行侵入，脑域防线正在被强行破解！ 通过这种暴力手段强行破解，有很大的几率会直接导致“漏洞”的死亡。在做意识保镖的时候，陈一没少用这种手段对付抓来的意识黑客。 可是，为什么是院长？ 在这一瞬间，陈一忽然感觉他心里一直想要掩藏的那一段珍贵，正摧枯拉朽般的轰然倒塌。 他一下子明白了罗三的话，自己不该回来。 怪不得即便自己用尽手段掩藏自己，追杀者总是能够找到自己！ 怪不得自己回来，院长没有显现出一丝一毫的惊讶！ 自己的行踪，一直都在院长的掌控之内！ “阿九，怎么样？数据是否保存完整？”院长出声问道。 一旁身穿白色大褂的背影回答：“还在破解脑域防火墙，不得不说，这小子真是个天才，这是我迄今为止破解时间最长的一次。” 听到这个声音，陈一先是一愣，接着他猛地转头看向拿到身影，瞬间心如死灰。 “段弛？”陈一开口道。声音如同砂砾一般。 “醒了？”院长见陈一醒来，表情没有丝毫波动，反而一脸关切地问：“小一，感觉怎么样？” 陈一双眼血红，死死地盯着院长，从牙缝中挤出一句话：“我真的没想到你也是组织的人。” “小一啊，我这也是为了你好。”院长语重心长地道。“你千不该，万不该去越过那道底线。你知道了那些东西，你就变成了一个定时炸弹，谁也不希望走到今天这一步不是？” 院长的话像是一道闷雷，让陈一瞬间坠入冰窟。但却又很快释然了。 是啊，每个人的底线都是不同的，每个人所背负的也都各不相同。为了心中的执念，可成佛，也可成魔。 陈一的底线是家，家没了，陈一也就失去了他的信念。 院长忠于组织，视组织内的规则为雷池，任何人都不可忤逆跨越。组织就是院长的家，陈一殃及了雷池，就要受到惩罚。 这是院长的规矩，也是组织的规矩。 陈一不会做出舍小家保大家这等傻事，但他会做出舍自己保小家这等更傻的事。 “你以为你是正义的伙伴？”院长摇摇头，叹息道。“在这个世界上，历史是由胜利者书写，正义的界限也是由胜利者规定，为什么？因为只有这样，胜利者才会更好的活下去。战胜时期，两国交战，你觉得谁是正义的一方？谁又是邪恶的一方？这样的划分本身就是个悖论。” “严格来说，我这样做，也是为了孤儿院，也是为了你的家啊。” 院长像是在说服陈一，又像是在娓娓道来一个冗长的老故事。 可陈一却一句都没听进去，他一遍又一遍地告诉自己，段弛不是宁九，段弛是自己的朋友，他是一个有味道，追逐自由的中年男人，他送给自己的平安符就是证据。 不过，段弛将永远地活在自己的心里，他不会再回来了。陈一悲惘的想着。 之后，陈一忽然取消了脑域的所有防线，将自己的脑电波频率调制到一个特殊的波段，然后决然的闭上了眼睛。 宁九面前的显示屏上，忽然跳出了一个对话框：“破解完成。” 八。 一声沉闷的巨响打破了实验室内的静谧，实验室的铁门被爆破，一排身着特殊黑色制服，手持枪械，全副武装的人冲进实验室，齐刷刷的将枪口对准了院长和宁九。 院长和宁九暗道一声不好，正欲进行意识侵入，却发现自己失去了“漏洞”的能力。 “怎么回事？” 这时，门口传来了不急不缓的脚步声，一个穿着格子衬衫，鼻梁上架着眼睛的年轻人走了进来，手里拿着一个类似小型雷达的装置，微笑道：“这是我的新发明，名叫哔哔啵啵，专门用来屏蔽脑电波信号，组织意识入侵。” 像是刻意在炫耀一般，梁孝语气夸张地问：“知道为什么叫哔哔啵啵吗？” 他走上前看着院长，微笑着说：“那是因为它运行的时候，会发出哔哔啵啵的声音。” 随即，梁孝向特战队员们发号施令：“全部给我带走！” 陈一躺在试验台上，看着冲自己微笑的梁孝，不禁感叹，人生的大起大落真是太刺激了！ 帮陈一解除了束缚，拔掉他脑袋上的电线，梁孝伸出手来说道：“重新认识一下，国家特别行动调查组成员，中科院最年轻的意识研究专家，梁孝。” “你的朋友，陈一。” 两人的手紧紧地握在了一起。 陈一看着梁孝那清澈的眼神，心道，原来你才是我最后的希望啊…… 九。 “MIC爆出惊天大丑闻，勾结国外政客资助恐怖分子！目前，MIC组织头号首脑已被抓获。” “被困意识保镖已悉数救出，国家表示将大力打击这种行为！” “无身体意识保镖实验被勒令截停，西方人道主义组织纷纷指责！” 陈一微微叹了口气，看向了身边的罗三，问道：“我想去看看他，你去吗？” 罗三想了想，还是摇了摇头，随即有些不解的问道：“你不恨他吗？” 陈一摇摇头说：“如果知道院长那孤儿院来当“漏洞”的培养基地，如果知道自己只是院长手中的利益牺牲品，孤儿院的每一个孩子都会恨他。但是，心中多一些希望，不是更好吗？” “我如果永远都不知道真相，那么，这些痛苦就永远都不会找上我。” 罗三哑然。 这时候，梁孝推门进来，满脸春风得意道：“陈一，多亏了你提供的关键资料，我当初果然没有看错，你简直就是把万能钥匙啊！” “MIC组织已经被彻底捣毁，“漏洞”意识潜入这项技术从今以后将会用在造福全人类这种关键的地方。对了，陈一，有没有兴趣跟我回中科院，我也给你个教授的头衔当当？” “算了吧！”陈一摆摆手道。“我可不想给你当小白鼠！” “哈哈。”梁孝大摇大摆的坐了下来，问：“那你接下来有什么打算？” “我要留在这家孤儿院。”陈一回答。 罗三像是早就看出了陈一的心思，对梁孝道：“你最好不要劝他，没有用的。” “对了。”陈一忽然纳闷。“你们两个是什么时候认识的？” “你能逃跑成功，其实都是因为我和梁孝在暗中帮你掩护。”罗三憨笑道。“每一个从孤儿院出去的“漏洞”，实际上都在院长的控制之内，梁孝很早就开始调查MIC案，在他找到这家孤儿院的时候，我们就达成了合作。之后，梁孝帮我抹除了院长设下的监视程序。” “我们先定了一个小目标，把你救出来。又定了一个大目标，就是通过你，协助梁孝破获MIC案。” 陈一完全明白了，原来一切都是罗三和梁孝设下的一个局，从自己携带重要机密逃出组织，到引蛇出洞，让院长这个组织高层浮出水面，之后，利用院长进行彻底的收网。 “原来你们两个才是黄雀啊……”陈一感叹道。 院长自认为螳螂捕蝉黄雀在后，猜对了开头，却没猜到结局。 “其实让我决定放手一搏的是我们一起种下的那棵树。”罗三说道。“他在我的精心照顾之下从一棵小树苗长成枝叶繁茂的大树，你不在的日子里，它就是我的兄弟。” “我看着它一点一点长大，给它浇水，施肥，守护着它不让孩子们在它身上乱刻乱画。我的初心不是等它长大的时候把它砍了当木材，而是看着它夏天时候绿意盎然的样子。嫌晒的时候，它还能为我遮挡火辣辣的阳光。” “人非草木，孰能无情？人非圣贤，孰能无过？” 罗三透过窗户看到铺满院子地上的金黄色落叶，叹了口气。 PS：很久以前写的一个短篇，现在看看觉得蛮有趣。","categories":[{"name":"小说","slug":"小说","permalink":"http://chronosblog.top/categories/小说/"}],"tags":[{"name":"小说","slug":"小说","permalink":"http://chronosblog.top/tags/小说/"}]}]